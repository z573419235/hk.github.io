<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>打工纪实</title>
  
  <subtitle>记录打工每一天</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://blog.mjava.top/"/>
  <updated>2021-07-22T03:30:13.219Z</updated>
  <id>http://blog.mjava.top/</id>
  
  <author>
    <name>ooooooh灰灰</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>UML箭头在Java中的含义</title>
    <link href="http://blog.mjava.top/gof/234C81B9931C44CB9B88E0E53210BB48/"/>
    <id>http://blog.mjava.top/gof/234C81B9931C44CB9B88E0E53210BB48/</id>
    <published>2021-07-18T20:17:38.000Z</published>
    <updated>2021-07-22T03:30:13.219Z</updated>
    
    <content type="html"><![CDATA[<h2 id="泛化"><a href="#泛化" class="headerlink" title="泛化"></a>泛化</h2><blockquote><p>在 Java 中表示继承关系，空心箭头指向父类</p></blockquote><p><img src="http://cdn.mjava.top/blog/fi3SUYimage-20210717181253414.png" alt="image-20210717181253414"></p><p><strong>示例：</strong></p><p><img src="http://cdn.mjava.top/blog/CWFFnaimage-20210718173428923.png" alt="image-20210718173428923"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son</span> <span class="keyword">extends</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><blockquote><p>表示实现接口，箭头指向接口类</p></blockquote><p><img src="http://cdn.mjava.top/blog/XoAFNsimage-20210717181304829.png" alt="image-20210717181304829"></p><p><strong>示例：</strong></p><p><img src="http://cdn.mjava.top/blog/OlaaSSimage-20210718173938989.png" alt="image-20210718173938989"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Iter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TerImpl</span> <span class="keyword">implements</span> <span class="title">Iter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h2><blockquote><p>表示依赖关系，某个类的方法必须依赖另一个类才可以执行，箭头指向被依赖的类</p></blockquote><p><img src="http://cdn.mjava.top/blog/9ULJU5image-20210718171936788.png" alt="image-20210718171936788"></p><p><strong>示例：</strong></p><p><img src="http://cdn.mjava.top/blog/YEh93vimage-20210718174817997.png" alt="image-20210718174817997"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testA</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"这是 A 类"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testB</span><span class="params">(A a)</span></span>&#123;</span><br><span class="line">        a.testA();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="关联关系"><a href="#关联关系" class="headerlink" title="关联关系"></a>关联关系</h2><h3 id="关联"><a href="#关联" class="headerlink" title="关联"></a>关联</h3><blockquote><p>表示关联关系，两个类的关系是平等的</p><p><strong>可以双向关联，A 可以关联 B，B 也可以关联 A</strong></p><p>箭头指向被关联的类</p></blockquote><p><img src="http://cdn.mjava.top/blog/effJpHimage-20210717181329532.png" alt="image-20210717181329532"></p><p><strong>示例：</strong></p><p><img src="http://cdn.mjava.top/blog/p17PX4image-20210718201348840.png" alt="image-20210718201348840"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testA</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"这是 A 类"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> A a;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">B</span><span class="params">(A a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.a = a;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testB</span><span class="params">()</span></span>&#123;</span><br><span class="line">        a.testA();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="聚合"><a href="#聚合" class="headerlink" title="聚合"></a>聚合</h3><blockquote><p>表示聚合关系，<strong>聚合是关联的一种特例，在代码上两者没有什么区别</strong>。</p><p><strong>单向关联，A 能关联 B，B 不能关联 A</strong></p><p>尾部为空棱形，也可以是直线</p></blockquote><p><img src="http://cdn.mjava.top/blog/fKgWIFimage-20210718195546287.png" alt="image-20210718195546287"></p><p><strong>示例：</strong></p><p><img src="http://cdn.mjava.top/blog/DvBzVKimage-20210718200435303.png" alt="image-20210718200435303"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;A&gt; a;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="组合"><a href="#组合" class="headerlink" title="组合"></a>组合</h3><blockquote><p>表示组合关系，也是<strong>关联关系的一种</strong></p><p>表示强关联关系，被关联的类的生命周期会随关联类的生命周期一起产生和消失</p></blockquote><p><img src="http://cdn.mjava.top/blog/15FMoXimage-20210718195556115.png" alt="image-20210718195556115"></p><p><strong>示例：</strong></p><p><img src="http://cdn.mjava.top/blog/1jOTPHimage-20210718201118928.png" alt="image-20210718201118928"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> A a;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">B</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.a = <span class="keyword">new</span> A();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>聚合和组合的区别：聚合是个体离开了整体，依然可以存在.<br>                                       组合是个体和整体不可以分开，个体不能离开整体单独存在。</p><p>依赖，关联 和聚合，组合的区别：依赖，关联 : 类之间的关系是在同一层次上.<br>                                                               聚合，组合: 类之间的关系表现为整体和部分。</p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul><li><a href="https://blog.csdn.net/zhuyu714997369/article/details/51983871" rel="noopener" target="_blank">https://blog.csdn.net/zhuyu714997369/article/details/51983871</a></li><li><a href="https://zhuanlan.zhihu.com/p/109655171" rel="noopener" target="_blank">https://zhuanlan.zhihu.com/p/109655171</a></li><li><a href="https://blog.csdn.net/qq_31655965/article/details/54645220" rel="noopener" target="_blank">https://blog.csdn.net/qq_31655965/article/details/54645220</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;泛化&quot;&gt;&lt;a href=&quot;#泛化&quot; class=&quot;headerlink&quot; title=&quot;泛化&quot;&gt;&lt;/a&gt;泛化&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;在 Java 中表示继承关系，空心箭头指向父类&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;ht
      
    
    </summary>
    
    
      <category term="UML" scheme="http://blog.mjava.top/categories/UML/"/>
    
    
      <category term="UML" scheme="http://blog.mjava.top/tags/UML/"/>
    
  </entry>
  
  <entry>
    <title>记一次很久以前做的梦【加密】</title>
    <link href="http://blog.mjava.top/archive/essay/8B40046C17644103BD2A256EB938884C/"/>
    <id>http://blog.mjava.top/archive/essay/8B40046C17644103BD2A256EB938884C/</id>
    <published>2021-07-15T08:14:37.000Z</published>
    <updated>2021-07-22T03:30:13.219Z</updated>
    
    <content type="html"><![CDATA[<h2 id="时间：2019-12-19-07-23"><a href="#时间：2019-12-19-07-23" class="headerlink" title="时间：2019-12-19 07:23"></a>时间：2019-12-19 07:23</h2><p>RGwc3OqLQr/FK7bX9qFgbl1FD1WZLruNkeFBP4vHyDejXpJhzV309eABiP0e+YiX5wKAD0GaALo74u1B39tyIUFaMrQAVV5M60sGphzkL2hf0ad5/0JAqGXgDy01ustT/w+bAGA8As3jc+3CexZ8CfqJsrOp7vt0aE8zzqKV0IbSL3b5u4wpBfp4Rb7+4b7lES9sbZmD37mXP5bJ0X94Z6W38oSSUj6aiLpDI9kllGxSWavZK+hQk1eWuAThn833cjXVtaxq7Mruglvc+eo4ok2Fm56uCdnq2RiUi5nu9e0bkGXyv8ELwr3RcVjMQdHQB8CK/OFuNXltCRWNKlH6G2fyrPO+D+Sg6zbolkLHl326Ja3co0fDuLm6MxbLLwubwjfci0/ZXjGOCKodAfvEtrDmkd0l2HYaOTbH6nOu+3GwXr+3QwdoxhFrVPjpkvjWcs4VNieiqiynXeNBflPR66ZrscQtZRVX77DUXT3jZdQ5rV7a6ZyWDr9ZgET86YQlGFxcW62wsBnMBt9STCFCUhbhYdccrBOAMJuZXfccIDuBgqelngufQRinLHRJiv0ihN2QhNuJFKkkTxSgswrMjLWhMGgKs8fbfnK82myiWIgqRnF6geCydTX8UAS3dTR1f0XJKEJuUNzc87uzszP+EZIcZ+JnCLjLNnJXJG9XVlLKElLmiwXNi4zDnP6NHGa7ikvac7mHR2SsWGL3/v4pZtSNiwoZW3pPaK6Id+eg+srKoB7GTQNKZIsDuJh8cMziJF7cr1KvH7LZRMpB4MpeyvLmgz8oo3soLiGFVhl5wMrcqbc8H4qtnC4mI9iT5Z1lPBtq13+bYyplOY+G0soMOvbtkei7nWxIz3fh17gqMZvlTikEGcMNHGTs+wwgtsbreqR54iWEVuOxfYD+eYArFujw+iJRCsUCYWepGeVGNpZwlsuKQ+EH0sIJ1c4srVN73BYyE9nHw34W9CHY1MkOhUmXflbaBxz7E+AWfiUiZEWpWwvXOfTtWRuJV0htuCPmA63XgHn6JAHadlf5OY4l1BNewOWXVDPYEChsONoPSmTFxjq/Qop83AqoOtxoaPqfWLXM+s8AqMjfWDQkzDMuxUnMO9fxiEze7J+qMZw7y2W+37NgPQHZBcG3Q8Vd/ArxjfMQaZO11cYsW+RQkhuXj6lvsbs31+j/Od4mA0XPpJ2rKIVC/ueVAP8BuTBAzMN8ndDHXkKctT17eCUXz7w+t9n4h4MZxQQPegz9d3ULLabcdCJ167fpJ+8/iXQhcJXihJeNXefkPcVrkxF+Tfj/r73rSbTgtK+LseIedY1u17/8itWpPlPqlVDC6dzSECBofynwSHADsXl+CBFpkstT3JPiSRTnVmWcta4H9kHthp4yG8Hqc2O6fJnodDIjwa6uzS0N8o95wHz79dDtDHKSpGsjtjotT54qCeI9z3T9FMSwKrN2AJn/1fQdRA56QjnGFLeE8EkYY5Ix6tsk9XFcqAeLC1UbWIoaEqUdILSo9e/TAUizEf+01YBHrsec+o2lEGl8QjthfxhlEFDNgTD0Lt4Cb2ytqpMJZXxFrqqUYOOc2+Lq0/xJPHCKHYf8vLZEfx7LzcLbwLk+BVnxm6JqQVXXWMM2BblrFCX2CAIuhd8m0lztKUrK5OVG0TyEeLrOpB6/YfXm6MPIOttooJFzCBZAKpWt70Xwwfwxrr7r0qMZziWv8oTiFG4lSvGE0VvCwN9hZoLvFh6bMFpnz/bv0L8HMSxBmOyanQm01HhX6KXcyNSbW9Ep2Qxkw+eC034r+HQzV2t+qFkbpNFMb0DatDetvdBZyvlTvlPNcxJCcxEqe/gxb9DRzKNPyy8eM/P4Wem+NW7GFZTfXZQ6uj712J/vQddDF9ukf/jXJkEShhLTs9+JFhR9zjnOljLfNhmB8UzIUBno1d+qqzlC+ZiHzkaRbMnATdOYqW0dBIf5f5wIq31M4GC5mkQzxBVQ8Zqxxu5LCLGRrm+2dro8O27/B5D74h0s/rUmbj8Qxxf32rNjj0+TAZIIFh/3pQjdbwNiABQZUpLBtYWSiZSZ5ivKAgzK6H1uVAlrillqMWJDjLsU6yO1sGb6lMBgKiIuGD2MWHj6moa+JUygW+gWo9m7XVe0q6y6CveMERblK4nXsgurUqH4j91uqyu6c0kccGY8Oei6opdzG49/53IJg8YQo6TnK+plLdg1ezfanf20QwHBV1IHNYFWiTUHVO88EJuvLSAPgDdiVCOzO0KjXxjqOiq7lDw+OFbYaYyUoE1nwywhgE1TbBJdR54em/CC4lY+14GNDTTAaN9ATWLCSPJWQnsDR799HCBZcGumWHB303Zcti4/hKKmUW1JH59XxL4dtLup7fER05tm7vtVJ5ZCd0r1+R7QOzPIszOqZ+B2OifcYLVAelM7OGtIZbOmIWQbU11K45P16Y6GVZicmSTPSKXrvAB6nhOD0/we/UbqpU6iNu5ZRTgcZcxyrgU2TzWaKgfcX5ynMjk0TAqvYKYHAXMhMIUE6tEMMithQ1WkasGcv0+r6Hu8jPrc9/Gvlf4u+4fl9knAf7JCgONAi4ds/p6rwGAGtZbvzcAvxF7p04RcX0MY6A53z0tsFIcE46Uu/KuxhWVyufVwlrHfIek6k8hHTspNH8bztwUJLU6gBRP9SpRrZrZIhDPII19VXNFVWdujdwcu7dcNuuoXPofulrbbHSyYaSaxK/RdHh7yjViodnoUp3WaTNDZtzRlICXyZm73kD7qqHyR6nyqnVFG43Zd+Xcic2HJzEhSMYG6Ddlyc6AzYSCJeoDCY9M6dpPFKplBpQRL8g4LjOLHwd7BMlXqqcvjAmJpfHSlByX5KEml7a3V4jVKoIhoq1B5EvoNELDwUah8nnJjh8CKJevnuNx2NRUr/QNzIfHTRGKCYHua70wUQX7m+lcNMc/EG3TLqr+qyXMFjXihPxRLL+Uc9LBDbCIMh1Zpirr/0+6U4twTr/ipWU5SmOxf0O+OFl2NjOH7u8MwkXT1yWTS09Nfu3tLHFA0EmqJxgceNea8uegh+KFo4Fnf4oTd1wwg6c3cE8RX7okJ5ZDMzWCifUEwzdturrhnaarzbZT/aCIAn4Epu4/G0wgJSZL5oos889CaEJcmGkkJ6XSTd87ArxLOu143GSoSxVj6dlMGYLfcnJIjX3NJ0kHJdSROY9f6Kd0Moh/3fupqbLxtyP9bKQKPtpfw4pT2/Kd2nmPeBhxMIqIap4b3zKL5PzBF/t6faSIMANeUoU9+oD1LU5FVfkoz5Icd7aW73SNLnwFxvXXUkuR/Dkcry3vJVOeKuxV6m6L6qqplQtCiyYzTc01Zllr4e34dYU0/QOfId3TI4Ork17iAHGGu+JY8Kud55p2Ph3NZN9nLryFzyjAsgaRY5YJnrJ0/vs+0yS3wLYvXWIy1rhJHytZRS7AzR+TjX+GRAFAajy5zkouA7owJbn1L8UFvzlbDTLFHzhxVMI+DsTddmNqU70wOP2Goh8c3HnOLf77Sn6l6qS+eL18+ZcTm8RhXN8+tT2/id+GLg60kgFIQggJVgQV8qKOqfSnyE4v1szSmSnGxrlZHNSzBg18XppzmNxAbNHjPiauLVGw/qPWvm4ZGvtYv23rLsA0cdLnjnmnlCg/oh/8juTf3GsX5VVS7sGIFZCJh/RRzLmwvXq2LZgBhhdD607xq7AFhuazYpVXcP6axrAWl3ikqYYGzAtesSzc/yK9hhhvPcO+UhhkfWrlLdubzSBP60ycIhCSMG+OhG2U5XZLaSpMZghnpf8tu2uFiH6xkiFHAunxseHecrBstXQZ4jzVL3aFv3TpyQG19dgKIlukZDpSFuLZLFW/fe5So5mNfp/zgezEXaZz/TIkD/HMpm18nov2oPuIOi2HFNwSZoExvORHzRCXcfci8/+m8VH9aF31EwiapPfFmjBWTAtcUI6s+T5Xf55d245Mi0XYQtWkqxLhIXfN0uyJBekVBNCKS7A2J0qjR5weYpAz/mnLX7xVfIGBanizxcag1GsOS70iPp4WuVTMrwVH9RvsCP+3n3wrMFkfrtQnjMx+GWJx3v3vl4fk1o5istwlrT3R3Z630OIgn6Wsdz43OWI4MIp8sJuKqQYntU7XkmSwxerSSOOr64+u9H3WKyUxzgQ8bEqH+i8xjRajjlrYQ8iZGr85c2JEE6HB7QcxbA6IpDz0WI7WdA2WBM/c5lGWNE+gMg7abztKO9CPnQscEvCZGr85c2JEE6HB7QcxbA6IpDz0WI7WdA2WBM/c5lGWNE+gMg7abztKO9CPnQscEvCZGr85c2JEE6HB7QcxbA6IpDz0WI7WdA2WBM/c5lGWNE+gMg7abztKO9CPnQscEvCZGr85c2JEE6HB7QcxbA6IpDz0WI7WdA2WBM/c5lGWNE+gMg7abztKO9CPnQscEvCZGr85c2JEE6HB7QcxbA6IpDz0WI7WdA2WBM/c5lGWNE+gMg7abztKO9CPnQscEvCZGr85c2JEE6HB7QcxbA6IpDz0WI7WdA2WBM/c5lGWNE+gMg7abztKO9CPnQscEvCZGr85c2JEE6HB7QcxbA6IpDz0WI7WdA2WBM/c5lGWNE+gMg7abztKO9CPnQscEvCZGr85c2JEE6HB7QcxbA6IpDz0WI7WdA2WBM/c5lGWNE+gMg7abztKO9CPnQscEvCZGr85c2JEE6HB7QcxbA6IpDz0WI7WdA2WBM/c5lGWNE+gMg7abztKO9CPnQscEvP0OhWvdMO2k9oBXJJ5MV/g=</p>]]></content>
    
    <summary type="html">
    
      本文采用AES-ECB模式 填充Pkcs7 加密，密文编码为base64。
    
    </summary>
    
    
      <category term="Essay" scheme="http://blog.mjava.top/categories/Essay/"/>
    
    
      <category term="抒发情感" scheme="http://blog.mjava.top/tags/%E6%8A%92%E5%8F%91%E6%83%85%E6%84%9F/"/>
    
  </entry>
  
  <entry>
    <title>Quarkus项目配置方式详解</title>
    <link href="http://blog.mjava.top/archive/quarkus/3EC6E900CDCB4BCEBA3B0BE40C9AADBB/"/>
    <id>http://blog.mjava.top/archive/quarkus/3EC6E900CDCB4BCEBA3B0BE40C9AADBB/</id>
    <published>2021-07-12T17:29:23.000Z</published>
    <updated>2021-07-22T03:30:13.219Z</updated>
    
    <content type="html"><![CDATA[<h2 id="配置加载流程"><a href="#配置加载流程" class="headerlink" title="配置加载流程"></a>配置加载流程</h2><p>Quarkus 可以从多个地方获取项目的配置，它读取配置优先级入下图，在下面的优先级中，一旦读取到某个配置，就不会再继续读取后面配置中的这个配置了。</p><p><img src="http://cdn.mjava.top/blog/0cvlsyconfig-sources.png" alt="config-sources"></p><h2 id="0x1-System-Properties"><a href="#0x1-System-Properties" class="headerlink" title="0x1 System Properties"></a>0x1 System Properties</h2><p>系统属性可以在启动期间通过 <code>-D</code> 标志传递给应用程序。</p><p>比如要设置 http 服务的运行端口，各个运行方式传递系统参数的方式如下：</p><ul><li><strong>Quarkus dev</strong>模式：<code>mvn quarkus:dev -Dquarkus.http.port=8888</code></li><li>运行 <strong>jar</strong> 包：<code>java -Dquarkus.http.port=8888 -jar quarkus-run.jar</code></li><li>运行 <strong>native-image</strong>：<code>app-runner -Dquarkus.http.port=8888</code></li></ul><h2 id="0x2-Environment-variables"><a href="#0x2-Environment-variables" class="headerlink" title="0x2 Environment variables"></a>0x2 Environment variables</h2><blockquote><p>环境变量的名字遵循 <a href="https://github.com/eclipse/microprofile-config/blob/master/spec/src/main/asciidoc/configsources.asciidoc#default-configsources" rel="noopener" target="_blank">MicroProfile Config</a></p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> Environment Variables Mapping Rules</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> Some operating systems allow only alphabetic characters or an underscore, _, <span class="keyword">in</span> environment variables. Other characters such as ., /, etc may be disallowed. In order to <span class="built_in">set</span> a value <span class="keyword">for</span> a config property that has a name containing such disallowed characters from an environment variable, the following rules are used.</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> </span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> The ConfigSource <span class="keyword">for</span> the environment variables searches three environment variables <span class="keyword">for</span> a given property name (e.g. com.ACME.size):</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> </span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> 1. Exact match (i.e. com.ACME.size)</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> </span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> 2. Replace each character that is neither alphanumeric nor _ with _ (i.e. com_ACME_size)</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> </span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> 3. Replace each character that is neither alphanumeric nor _ with _; <span class="keyword">then</span> convert the name to upper <span class="keyword">case</span> (i.e. COM_ACME_SIZE)</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> </span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> The first environment variable that is found is returned by this ConfigSource.</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"></span></span><br></pre></td></tr></table></figure></blockquote><p>环境变量的话各个系统设置的方式不一样，具体可以查一下自己系统设置环境变量的方式，一般 <strong>Unix</strong> 类的系统设置环境变量一般分为<strong>命令行设置</strong>和<strong>环境变量文件配置</strong></p><ul><li>命令行配置：<code>export QUARKUS_HTTP_PORT:8888</code></li><li>配置文件配置：环境变量配置文件又分用户变量配置文件和系统变量配置文件，直接在对应的配置文件里加上这一样就可以了，但是一般不推荐这么用</li></ul><h2 id="0x3-env-文件"><a href="#0x3-env-文件" class="headerlink" title="0x3 .env 文件"></a>0x3 .env 文件</h2><blockquote><p><strong>注意：.env 文件中的环境变量无法像普通的环境变量通过 System.getenv(String) API 获得。</strong></p></blockquote><p><code>.env</code> 文件的作用和环境变量类似，但是作用域更小，<strong>它只作用于当前项目，不像环境变量可以作用于所有项目</strong>。</p><p>它的设置方式是在 <code>.env</code> 文件里配置键值对的方式来设置变量，键名称和设置环境变量一样遵守 <a href="https://github.com/eclipse/microprofile-config/blob/master/spec/src/main/asciidoc/configsources.asciidoc#default-configsources" rel="noopener" target="_blank">MicroProfile Config</a> 规范</p><p>使用方式：</p><ul><li>对于 <strong>dev</strong> 模式：可以放在项目的根目录下来使用，<strong>但是不要把它和代码一起打包</strong></li><li>对于 <strong>jar</strong> 和 <strong>native-image</strong> 运行方式下：可以将 <code>.env</code> 文件放在和 jar 包或 native-image 同一目录下</li></ul><h2 id="0x4-Quarkus-Application配置文件"><a href="#0x4-Quarkus-Application配置文件" class="headerlink" title="0x4 Quarkus Application配置文件"></a>0x4 Quarkus Application配置文件</h2><p>Quarkus 和 Spring Boot 项目一样，支持 <code>application.properties</code> 配置文件。同时在 <strong>jar</strong> 包和 <strong>native-image</strong> 的运行模式下还支持当前 jar 文件和native-image 文件同目录下 <strong>config 文件夹</strong>里的 <code>application.properties</code> 配置文件，并且 <strong>config 文件夹</strong>里的配置文件优先级高于项目 <strong>resources 文件夹</strong>里的配置文件</p><blockquote><p>对于 dev 的运行模式下，项目也可以使用 config 文件里的配置文件，就是手动把 config 文件夹移到 <strong>target 文件夹</strong>里，但是在使用 <code>mvn clean</code> 命令时会把这个文件夹清理掉，到时候又要自己手动重新创建 config 文件夹和里面的配置文件，所以在 dev 模式下不推荐使用 <code>config/application.properties</code></p></blockquote><h2 id="0x5-MicroProfile-配置文件"><a href="#0x5-MicroProfile-配置文件" class="headerlink" title="0x5 MicroProfile 配置文件"></a>0x5 MicroProfile 配置文件</h2><p>它放在 <code>src/main/resources/META-INF/microprofile-config.properties</code> 里</p><p>它的工作原理和项目的 resources 文件夹下的 application.properties 完全相同，建议使用 resources 文件夹下的配置文件</p><h2 id="使用-yml-配置文件"><a href="#使用-yml-配置文件" class="headerlink" title="使用 yml 配置文件"></a>使用 yml 配置文件</h2><p>以上配置中，除了系统属性、环境变量、.env 文件外，配置文件都可以支持 yml 格式的配置，不过需要额外添加依赖</p><h3 id="添加依赖"><a href="#添加依赖" class="headerlink" title="添加依赖"></a>添加依赖</h3><ol><li><p>pom.xml 文件添加依赖</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.quarkus<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>quarkus-config-yaml<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>或者可以直接用 maven 命令来添加拓展依赖</p></li></ol><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./mvnw quarkus:add-extension -Dextensions="io.quarkus:quarkus-config-yaml"</span><br></pre></td></tr></table></figure><h3 id="添加yml文件"><a href="#添加yml文件" class="headerlink" title="添加yml文件"></a>添加yml文件</h3><p>移除<code>src/main/resources/application.properties</code> 文件，添加 <code>src/main/resources/application.yaml</code> 文件</p><p>如果两个文件都存在，Quarkus 会优先使用来自 <code>yml</code> 的配置，然后再使用 <code>properties</code> 的配置，所以为了不搞混淆，建议删除 <code>properties</code> 文件。</p><p>配置文件扩展名支持 <code>yml</code> 和 <code>yaml</code></p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol><li><a href="https://quarkus.io/guides/config-yaml" rel="noopener" target="_blank">https://quarkus.io/guides/config-yaml</a></li><li><a href="https://quarkus.pro/guides/config.html" rel="noopener" target="_blank">https://quarkus.pro/guides/config.html</a></li><li><a href="https://quarkus.io/guides/config-reference" rel="noopener" target="_blank">https://quarkus.io/guides/config-reference</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;配置加载流程&quot;&gt;&lt;a href=&quot;#配置加载流程&quot; class=&quot;headerlink&quot; title=&quot;配置加载流程&quot;&gt;&lt;/a&gt;配置加载流程&lt;/h2&gt;&lt;p&gt;Quarkus 可以从多个地方获取项目的配置，它读取配置优先级入下图，在下面的优先级中，一旦读取到某个配置，
      
    
    </summary>
    
    
      <category term="Quarkus" scheme="http://blog.mjava.top/categories/Quarkus/"/>
    
    
      <category term="Quarkus" scheme="http://blog.mjava.top/tags/Quarkus/"/>
    
  </entry>
  
  <entry>
    <title>Quarkus构建native-image遇到的问题及解决</title>
    <link href="http://blog.mjava.top/archive/quarkus/5756337C1CEA4B599E678A3380DCFE00/"/>
    <id>http://blog.mjava.top/archive/quarkus/5756337C1CEA4B599E678A3380DCFE00/</id>
    <published>2021-07-09T17:44:33.000Z</published>
    <updated>2021-07-22T03:30:13.219Z</updated>
    
    <content type="html"><![CDATA[<h2 id="本机构建-native-image"><a href="#本机构建-native-image" class="headerlink" title="本机构建 native-image"></a>本机构建 native-image</h2><p>如果你本地安装了 Graal VM 的话，可以在项目目录下直接执行：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mvn clean package -Pnative</span><br></pre></td></tr></table></figure><p>构建的时间比较长，构建完成后就会在 <code>./target</code> 目录下生成一个二进制执行文件，一般名字是 <code>quarkus-demo-1.0-runner</code>，直接执行这个二进制文件就可以运行项目了。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">➜  target: ./quarkus-demo-1.0-runner </span><br><span class="line">__  ____  __  _____   ___  __ ____  ______ </span><br><span class="line"> --/ __ \/ / / / _ | / _ \/ //_/ / / / __/ </span><br><span class="line"> -/ /_/ / /_/ / __ |/ , _/ ,&lt; / /_/ /\ \   </span><br><span class="line">--\___\_\____/_/ |_/_/|_/_/|_|\____/___/   </span><br><span class="line">2021-07-09 16:54:10,812 INFO  [io.quarkus] (main) quarkus-demo 1.0 native (powered by Quarkus 2.0.1.Final) started in 0.121s. Listening on: http://0.0.0.0:8080</span><br><span class="line">2021-07-09 16:54:11,041 INFO  [io.quarkus] (main) Profile prod activated. </span><br><span class="line">2021-07-09 16:54:11,041 INFO  [io.quarkus] (main) Installed features: [cdi, resteasy, smallrye-context-propagation]</span><br><span class="line">^C2021-07-09 16:55:12,904 INFO  [io.quarkus] (Shutdown thread) quarkus-demo stopped in 0.008s</span><br></pre></td></tr></table></figure><h2 id="容器构建-native-image"><a href="#容器构建-native-image" class="headerlink" title="容器构建 native-image"></a>容器构建 native-image</h2><p>如果你本地没有安装 Graal VM 的话，Quarkus 官方还提供了一个构建的基础镜像：<code>quay.io/quarkus/ubi-quarkus-native-image</code>，我们可以直接执行以下命令进行构建：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mvn clean package -Pnative -Dquarkus.native.container-build=true</span><br></pre></td></tr></table></figure><h3 id="容器构建遇到的问题"><a href="#容器构建遇到的问题" class="headerlink" title="容器构建遇到的问题"></a>容器构建遇到的问题</h3><h4 id="1-构建时内存不足"><a href="#1-构建时内存不足" class="headerlink" title="1. 构建时内存不足"></a>1. 构建时内存不足</h4><p>在使用容器构建 native-image 的时候，可以会报如下错误：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[ERROR] Failed to execute goal io.quarkus:quarkus-maven-plugin:2.0.1.Final:build (default) on project quarkus-demo: Failed to build quarkus application: io.quarkus.builder.BuildException: Build failure: Build failed due to errors</span><br><span class="line">[ERROR]         [error]: Build step io.quarkus.deployment.pkg.steps.NativeImageBuildStep#build threw an exception: java.lang.RuntimeException: Failed to build native image</span><br><span class="line">[ERROR]         at io.quarkus.deployment.pkg.steps.NativeImageBuildStep.build(NativeImageBuildStep.java:223)</span><br><span class="line">[ERROR]         at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)</span><br><span class="line">[ERROR]         at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)</span><br><span class="line">[ERROR]         at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)</span><br><span class="line">[ERROR]         at java.base/java.lang.reflect.Method.invoke(Method.java:566)</span><br><span class="line">[ERROR]         at io.quarkus.deployment.ExtensionLoader$2.execute(ExtensionLoader.java:820)</span><br><span class="line">[ERROR]         at io.quarkus.builder.BuildContext.run(BuildContext.java:277)</span><br><span class="line">[ERROR]         at org.jboss.threads.ContextHandler$1.runWith(ContextHandler.java:18)</span><br><span class="line">[ERROR]         at org.jboss.threads.EnhancedQueueExecutor$Task.run(EnhancedQueueExecutor.java:2442)</span><br><span class="line">[ERROR]         at org.jboss.threads.EnhancedQueueExecutor$ThreadBody.run(EnhancedQueueExecutor.java:1476)</span><br><span class="line">[ERROR]         at java.base/java.lang.Thread.run(Thread.java:829)</span><br><span class="line">[ERROR]         at org.jboss.threads.JBossThread.run(JBossThread.java:501)</span><br><span class="line">[ERROR] Caused by: java.lang.RuntimeException: Image generation failed. Exit code was 137 which indicates an out of memory error. Consider increasing the Xmx value for native image generation by setting the "quarkus.native.native-image-xmx" property</span><br><span class="line">[ERROR]         at io.quarkus.deployment.pkg.steps.NativeImageBuildStep.imageGenerationFailed(NativeImageBuildStep.java:360)</span><br><span class="line">[ERROR]         at io.quarkus.deployment.pkg.steps.NativeImageBuildStep.build(NativeImageBuildStep.java:200)</span><br><span class="line">[ERROR]         ... 11 more</span><br><span class="line">[ERROR] -&gt; [Help 1]</span><br><span class="line">[ERROR] </span><br><span class="line">[ERROR] To see the full stack trace of the errors, re-run Maven with the -e switch.</span><br><span class="line">[ERROR] Re-run Maven using the -X switch to enable full debug logging.</span><br><span class="line">[ERROR] </span><br><span class="line">[ERROR] For more information about the errors and possible solutions, please read the following articles:</span><br><span class="line">[ERROR] [Help 1] http://cwiki.apache.org/confluence/display/MAVEN/MojoExecutionException</span><br></pre></td></tr></table></figure><p>错误提示时内存不足，可以尝试设置 <code>quarkus.native.native-image-xmx</code> 参数，但是设置了这个参数还是报这个错。在查阅资料后，在一个 <a href="https://stackoverflow.com/questions/55157074/packaging-native-image-using-graalvm-and-quarkus-gave-an-error" rel="noopener" target="_blank">stackoverflow</a> 的回答中看到了这样一句话：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Pay attention it has to be less than the memory you set in your docker daemon.</span><br></pre></td></tr></table></figure><p>他说必须小于您在 docker 守护进程中设置的内存。</p><p>然后我查看 docker 的官方文档时发现，在 Mac 和 Windows 中默认的内存是 2GB。</p><p>所以只要调高这个值就可以了，推荐是 8GB，各系统设置方法：</p><p>Mac：<a href="https://docs.docker.com/docker-for-mac/#resources" rel="noopener" target="_blank">https://docs.docker.com/docker-for-mac/#resources</a></p><p>Windows：<a href="https://docs.docker.com/docker-for-windows/#resources" rel="noopener" target="_blank">https://docs.docker.com/docker-for-windows/#resources</a></p><h4 id="2-容器构建后的二进制文件无法运行"><a href="#2-容器构建后的二进制文件无法运行" class="headerlink" title="2. 容器构建后的二进制文件无法运行"></a>2. 容器构建后的二进制文件无法运行</h4><p>容器构建 native-image 完成后生成的二进制文件不能执行，提示 <code>zsh: exec format error: ./quarkus-demo-1.0-runner</code></p><p>这是因为我本机是 Mac 系统，但是 Quarkus 提供的构建镜像是 Linux 系统，但是 <strong>Graal VM 目前好像并不支持交叉编译</strong>，所以在 Linux 系统里构建的二进制文件只能在 Linux 系统里执行。</p><p>所以我们可以直接用容器来运行这个构建好的二进制文件。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;本机构建-native-image&quot;&gt;&lt;a href=&quot;#本机构建-native-image&quot; class=&quot;headerlink&quot; title=&quot;本机构建 native-image&quot;&gt;&lt;/a&gt;本机构建 native-image&lt;/h2&gt;&lt;p&gt;如果你本地安装了 G
      
    
    </summary>
    
    
      <category term="Quarkus" scheme="http://blog.mjava.top/categories/Quarkus/"/>
    
    
      <category term="Quarkus" scheme="http://blog.mjava.top/tags/Quarkus/"/>
    
      <category term="Graal VM" scheme="http://blog.mjava.top/tags/Graal-VM/"/>
    
  </entry>
  
  <entry>
    <title>使用Maven工具创建Quarkus项目</title>
    <link href="http://blog.mjava.top/archive/quarkus/5870388109C640649633FA0BB2F5C9C1/"/>
    <id>http://blog.mjava.top/archive/quarkus/5870388109C640649633FA0BB2F5C9C1/</id>
    <published>2021-07-09T15:22:39.000Z</published>
    <updated>2021-07-22T03:30:13.219Z</updated>
    
    <content type="html"><![CDATA[<h2 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h2><p>我这边使用的是 <code>Maven 3.8.1</code>  版本，可以使用 Quarkus 官方提供的 <code>io.quarkus:quarkus-maven-plugin:2.0.1.Final</code>  插件来快速穿件 Quarkus 项目。</p><h2 id="创建项目"><a href="#创建项目" class="headerlink" title="创建项目"></a>创建项目</h2><p>使用以下 Maven 命令来创建一个新项目：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mvn io.quarkus:quarkus-maven-plugin:2.0.1.Final:create \</span><br><span class="line">    -DprojectGroupId=top.mjava \</span><br><span class="line">    -DprojectArtifactId=quarkus-demo \</span><br><span class="line">    -DprojectVersion=1.0 \</span><br><span class="line">    -DclassName="top.mjava.demo.Application"</span><br></pre></td></tr></table></figure><p>在执行命令的当前目录下会为项目生成和 ArtifactId 同名的文件夹，如果已存在该同名文件夹，则项目会创建失败。</p><p>在 <code>src/main/docker</code> 目录下还生成了 native 和 jvm 模式的 Dockerfile，构建镜像和运行容器的指令写在这些 Dockerfile 中。</p><h3 id="命令描述"><a href="#命令描述" class="headerlink" title="命令描述"></a>命令描述</h3><table><thead><tr><th align="left">属性</th><th align="left">默认值</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><code>projectGroupId</code></td><td align="left"><code>org.acme.sample</code></td><td align="left">项目的 GroupId</td></tr><tr><td align="left"><code>projectArtifactId</code></td><td align="left">没有默认值，但是必填</td><td align="left">项目的 ArtifactId</td></tr><tr><td align="left"><code>projectVersion</code></td><td align="left"><code>1.0.0-SNAPSHOT</code></td><td align="left">项目版本</td></tr><tr><td align="left"><code>platformGroupId</code></td><td align="left"><code>io.quarkus</code></td><td align="left">目标平台的组 ID。鉴于所有现有平台都来自 io.quarkus，实际上不会明确使用这一平台。但它仍然是一个选择。</td></tr><tr><td align="left"><code>platformArtifactId</code></td><td align="left"><code>quarkus-universe-bom</code></td><td align="left">目标平台 BOM 的工件 ID。为了使用本地构建的 Quarkus，它应该是 quarkus-bom。</td></tr><tr><td align="left"><code>platformVersion</code></td><td align="left">如果未指定，将解析最新的。</td><td align="left">您希望项目使用的平台版本。它还可以接受版本范围，在这种情况下，将使用指定范围中的最新版本。</td></tr><tr><td align="left"><code>className</code></td><td align="left"><em>如果省略则不创建</em></td><td align="left">生成的资源的完全限定名称</td></tr><tr><td align="left"><code>path</code></td><td align="left"><code>/hello</code></td><td align="left">资源路径，仅在设置了 className 时生效。</td></tr><tr><td align="left"><code>extensions</code></td><td align="left"><em>[]</em></td><td align="left">要添加到项目的扩展列表（逗号分隔）</td></tr></tbody></table><h2 id="管理扩展"><a href="#管理扩展" class="headerlink" title="管理扩展"></a>管理扩展</h2><p>创建项目后就可以进入到项目文件夹，可以使用简短的命令来操作项目了，例如：<code>mvn quarkus:[command]</code></p><h3 id="查看所有扩展"><a href="#查看所有扩展" class="headerlink" title="查看所有扩展"></a>查看所有扩展</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mvn quarkus:list-extensions</span><br></pre></td></tr></table></figure><p>该命令可以查看当前项目所使用的的所有扩展。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">➜  quarkus-demo: mvn quarkus:list-extensions</span><br><span class="line">[INFO] Scanning for projects...</span><br><span class="line">[INFO] </span><br><span class="line">[INFO] -----------------------&lt; top.mjava:quarkus-demo &gt;-----------------------</span><br><span class="line">[INFO] Building quarkus-demo 1.0</span><br><span class="line">[INFO] --------------------------------[ jar ]---------------------------------</span><br><span class="line">[INFO] </span><br><span class="line">[INFO] --- quarkus-maven-plugin:2.0.1.Final:list-extensions (default-cli) @ quarkus-demo ---</span><br><span class="line">[INFO] Current Quarkus extensions available: </span><br><span class="line">[INFO] </span><br><span class="line">[INFO] Blaze-Persistence                                  blaze-persistence-integration-quarkus             </span><br><span class="line">[INFO] Camel ActiveMQ                                     camel-quarkus-activemq                            </span><br><span class="line">[INFO] Camel Async HTTP Client (AHC)                      camel-quarkus-ahc                                 </span><br><span class="line">[INFO] Camel Async HTTP Client (AHC) Websocket            camel-quarkus-ahc-ws                              </span><br><span class="line">[INFO] Camel AMQP                                         camel-quarkus-amqp           </span><br><span class="line">......</span><br></pre></td></tr></table></figure><h3 id="添加扩展"><a href="#添加扩展" class="headerlink" title="添加扩展"></a>添加扩展</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mvn quarkus:add-extensions -Dextension=vertx</span><br></pre></td></tr></table></figure><p>该命令可以添加扩展，例如上面这条命令为项目添加了 <code>vertx</code> 扩展</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">➜  quarkus-demo: mvn quarkus:add-extensions -Dextension=vertx</span><br><span class="line">[INFO] Scanning for projects...</span><br><span class="line">[INFO] </span><br><span class="line">[INFO] -----------------------&lt; top.mjava:quarkus-demo &gt;-----------------------</span><br><span class="line">[INFO] Building quarkus-demo 1.0</span><br><span class="line">[INFO] --------------------------------[ jar ]---------------------------------</span><br><span class="line">[INFO] </span><br><span class="line">[INFO] --- quarkus-maven-plugin:2.0.1.Final:add-extensions (default-cli) @ quarkus-demo ---</span><br><span class="line">[INFO] [SUCCESS] ✅  Extension io.quarkus:quarkus-vertx has been installed</span><br><span class="line">[INFO] ------------------------------------------------------------------------</span><br><span class="line">[INFO] BUILD SUCCESS</span><br><span class="line">[INFO] ------------------------------------------------------------------------</span><br><span class="line">[INFO] Total time:  2.370 s</span><br><span class="line">[INFO] Finished at: 2021-07-09T15:06:50+08:00</span><br><span class="line">[INFO] ------------------------------------------------------------------------</span><br></pre></td></tr></table></figure><h3 id="删除扩展"><a href="#删除扩展" class="headerlink" title="删除扩展"></a>删除扩展</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mvn quarkus:remove-extensions -Dextension=vertx</span><br></pre></td></tr></table></figure><p>该命令可以删除不用的扩展，比如删除刚刚添加的 <code>vertx</code> 扩展</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">➜  quarkus-demo: mvn quarkus:remove-extensions -Dextension=vertx</span><br><span class="line">[INFO] Scanning for projects...</span><br><span class="line">[INFO] </span><br><span class="line">[INFO] -----------------------&lt; top.mjava:quarkus-demo &gt;-----------------------</span><br><span class="line">[INFO] Building quarkus-demo 1.0</span><br><span class="line">[INFO] --------------------------------[ jar ]---------------------------------</span><br><span class="line">[INFO] </span><br><span class="line">[INFO] --- quarkus-maven-plugin:2.0.1.Final:remove-extensions (default-cli) @ quarkus-demo ---</span><br><span class="line">[INFO] [SUCCESS] ✅  Extension io.quarkus:quarkus-vertx has been uninstalled</span><br><span class="line">[INFO] ------------------------------------------------------------------------</span><br><span class="line">[INFO] BUILD SUCCESS</span><br><span class="line">[INFO] ------------------------------------------------------------------------</span><br><span class="line">[INFO] Total time:  2.112 s</span><br><span class="line">[INFO] Finished at: 2021-07-09T15:08:48+08:00</span><br><span class="line">[INFO] ------------------------------------------------------------------------</span><br></pre></td></tr></table></figure><h2 id="项目构建"><a href="#项目构建" class="headerlink" title="项目构建"></a>项目构建</h2><h3 id="运行项目"><a href="#运行项目" class="headerlink" title="运行项目"></a>运行项目</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mvn quarkus:dev</span><br></pre></td></tr></table></figure><p>执行该命令时，项目会被运行，此时访问 <a href="http://localhost:8080/hello" rel="noopener" target="_blank">http://localhost:8080/hello</a> 就会得到 <code>Hello RESTEasy</code> 输出</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">  quarkus-demo: mvn quarkus:dev                             </span><br><span class="line">[INFO] Scanning for projects...</span><br><span class="line">[INFO] </span><br><span class="line">[INFO] -----------------------&lt; top.mjava:quarkus-demo &gt;-----------------------</span><br><span class="line">[INFO] Building quarkus-demo 1.0</span><br><span class="line">[INFO] --------------------------------[ jar ]---------------------------------</span><br><span class="line">[INFO] </span><br><span class="line">[INFO] --- quarkus-maven-plugin:2.0.1.Final:dev (default-cli) @ quarkus-demo ---</span><br><span class="line">[INFO] Invoking io.quarkus:quarkus-maven-plugin:2.0.1.Final:generate-code @ quarkus-demo</span><br><span class="line">[INFO] Invoking org.apache.maven.plugins:maven-resources-plugin:2.6:resources @ quarkus-demo</span><br><span class="line">[INFO] Using 'UTF-8' encoding to copy filtered resources.</span><br><span class="line">[INFO] Copying 2 resources</span><br><span class="line">[INFO] Invoking org.apache.maven.plugins:maven-compiler-plugin:3.8.1:compile @ quarkus-demo</span><br><span class="line">[INFO] Nothing to compile - all classes are up to date</span><br><span class="line">[INFO] Invoking org.apache.maven.plugins:maven-resources-plugin:2.6:testResources @ quarkus-demo</span><br><span class="line">[INFO] Using 'UTF-8' encoding to copy filtered resources.</span><br><span class="line">[INFO] skip non existing resourceDirectory /Users/zheng/coding/study/quarkus-demo/src/test/resources</span><br><span class="line">[INFO] Invoking org.apache.maven.plugins:maven-compiler-plugin:3.8.1:testCompile @ quarkus-demo</span><br><span class="line">[INFO] Nothing to compile - all classes are up to date</span><br><span class="line">Listening for transport dt_socket at address: 5005</span><br><span class="line">__  ____  __  _____   ___  __ ____  ______ </span><br><span class="line"> --/ __ \/ / / / _ | / _ \/ //_/ / / / __/ </span><br><span class="line"> -/ /_/ / /_/ / __ |/ , _/ ,&lt; / /_/ /\ \   </span><br><span class="line">--\___\_\____/_/ |_/_/|_/_/|_|\____/___/   </span><br><span class="line">2021-07-09 15:16:47,146 INFO  [io.quarkus] (Quarkus Main Thread) quarkus-demo 1.0 on JVM (powered by Quarkus 2.0.1.Final) started in 3.412s. Listening on: http://localhost:8080</span><br><span class="line">2021-07-09 15:16:47,194 INFO  [io.quarkus] (Quarkus Main Thread) Profile dev activated. Live Coding activated.</span><br><span class="line">2021-07-09 15:16:47,199 INFO  [io.quarkus] (Quarkus Main Thread) Installed features: [cdi, resteasy, smallrye-context-propagation]</span><br></pre></td></tr></table></figure><h3 id="构建项目"><a href="#构建项目" class="headerlink" title="构建项目"></a>构建项目</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mvn quarkus:build</span><br></pre></td></tr></table></figure><p>该命令会构建项目，并会在 <code>target/quarkus-app/</code> 目录下创建一个可运行的 <code>jar</code> 包</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">➜  quarkus-demo mvn quarkus:build</span><br><span class="line">[INFO] Scanning for projects...</span><br><span class="line">[INFO] </span><br><span class="line">[INFO] -----------------------&lt; top.mjava:quarkus-demo &gt;-----------------------</span><br><span class="line">[INFO] Building quarkus-demo 1.0</span><br><span class="line">[INFO] --------------------------------[ jar ]---------------------------------</span><br><span class="line">[INFO] </span><br><span class="line">[INFO] --- quarkus-maven-plugin:2.0.1.Final:build (default-cli) @ quarkus-demo ---</span><br><span class="line">[INFO] [org.jboss.threads] JBoss Threads version 3.4.0.Final</span><br><span class="line">[INFO] [io.quarkus.deployment.QuarkusAugmentor] Quarkus augmentation completed in 1977ms</span><br><span class="line">[INFO] ------------------------------------------------------------------------</span><br><span class="line">[INFO] BUILD SUCCESS</span><br><span class="line">[INFO] ------------------------------------------------------------------------</span><br><span class="line">[INFO] Total time:  4.776 s</span><br><span class="line">[INFO] Finished at: 2021-07-09T15:13:54+08:00</span><br><span class="line">[INFO] ------------------------------------------------------------------------</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>更多命令可以执行下面的命令查看，本文只介绍了几种常用的</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mvn io.quarkus:quarkus-maven-plugin:2.0.1.Final:help</span><br><span class="line"></span><br><span class="line">// 或者在项目目录下可使用简短命令</span><br><span class="line">mvn quarkus:help</span><br></pre></td></tr></table></figure><p>参考资料：<a href="https://quarkus.io/guides/maven-tooling" rel="noopener" target="_blank">https://quarkus.io/guides/maven-tooling</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;环境&quot;&gt;&lt;a href=&quot;#环境&quot; class=&quot;headerlink&quot; title=&quot;环境&quot;&gt;&lt;/a&gt;环境&lt;/h2&gt;&lt;p&gt;我这边使用的是 &lt;code&gt;Maven 3.8.1&lt;/code&gt;  版本，可以使用 Quarkus 官方提供的 &lt;code&gt;io.quark
      
    
    </summary>
    
    
      <category term="Quarkus" scheme="http://blog.mjava.top/categories/Quarkus/"/>
    
    
      <category term="Quarkus" scheme="http://blog.mjava.top/tags/Quarkus/"/>
    
      <category term="Maven" scheme="http://blog.mjava.top/tags/Maven/"/>
    
  </entry>
  
  <entry>
    <title>开发SaaS应用的12条准则【转】</title>
    <link href="http://blog.mjava.top/archive/code/FFC3580D7E244B5282E3FDD7F3EB8E95/"/>
    <id>http://blog.mjava.top/archive/code/FFC3580D7E244B5282E3FDD7F3EB8E95/</id>
    <published>2021-07-07T17:33:40.000Z</published>
    <updated>2021-07-22T03:30:13.219Z</updated>
    
    <content type="html"><![CDATA[<h1 id="开发SaaS应用的12条准则【转】"><a href="#开发SaaS应用的12条准则【转】" class="headerlink" title="开发SaaS应用的12条准则【转】"></a>开发SaaS应用的12条准则【转】</h1><blockquote><p>原文地址：<a href="https://12factor.net/" rel="noopener" target="_blank">https://12factor.net/</a></p></blockquote><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>如今，软件通常会作为一种服务来交付，它们被称为网络应用程序，或软件即服务（SaaS）。12-Factor 为构建如下的 SaaS 应用提供了方法论：</p><ul><li>使用<strong>标准化</strong>流程自动配置，从而使新的开发者花费最少的学习成本加入这个项目。</li><li>和操作系统之间尽可能的<strong>划清界限</strong>，在各个系统中提供<strong>最大的可移植性</strong>。</li><li>适合<strong>部署</strong>在现代的<strong>云计算平台</strong>，从而在服务器和系统管理方面节省资源。</li><li>将开发环境和生产环境的<strong>差异降至最低</strong>，并使用<strong>持续交付</strong>实施敏捷开发。</li><li>可以在工具、架构和开发流程不发生明显变化的前提下实现<strong>扩展</strong>。</li></ul><p>这套理论适用于任意语言和后端服务（数据库、消息队列、缓存等）开发的应用程序。</p><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>本文的贡献者参与过数以百计的应用程序的开发和部署，并通过 <a href="http://www.heroku.com/" rel="noopener" target="_blank">Heroku</a> 平台间接见证了数十万应用程序的开发，运作以及扩展的过程。</p><p>本文综合了我们关于 SaaS 应用几乎所有的经验和智慧，是开发此类应用的理想实践标准，并特别关注于应用程序如何保持良性成长，开发者之间如何进行有效的代码协作，以及如何 <a href="http://blog.heroku.com/archives/2011/6/28/the_new_heroku_4_erosion_resistance_explicit_contracts/" rel="noopener" target="_blank">避免软件污染</a> 。</p><p>我们的初衷是分享在现代软件开发过程中发现的一些系统性问题，并加深对这些问题的认识。我们提供了讨论这些问题时所需的共享词汇，同时使用相关术语给出一套针对这些问题的广义解决方案。本文格式的灵感来自于 Martin Fowler 的书籍： <em><a href="http://books.google.com/books/about/Patterns_of_enterprise_application_archi.html?id=FyWZt5DdvFkC" rel="noopener" target="_blank">Patterns of Enterprise Application Architecture</a></em> ， <em><a href="http://books.google.com/books/about/Refactoring.html?id=1MsETFPD3I0C" rel="noopener" target="_blank">Refactoring</a></em> 。</p><h2 id="读者应该是哪些人？"><a href="#读者应该是哪些人？" class="headerlink" title="读者应该是哪些人？"></a>读者应该是哪些人？</h2><p>任何 SaaS 应用的开发人员。部署和管理此类应用的运维工程师。</p><hr><h2 id="I-基准代码"><a href="#I-基准代码" class="headerlink" title="I. 基准代码"></a>I. 基准代码</h2><blockquote><p>一份基准代码（Codebase），多份部署（deploy）</p></blockquote><p><img src="https://12factor.net/images/codebase-deploys.png" alt="https://12factor.net/images/codebase-deploys.png"></p><p>12-Factor应用(译者注：应该是说一个使用本文概念来设计的应用，下同)通常会使用版本控制系统加以管理，如<a href="http://git-scm.com/" rel="noopener" target="_blank">Git</a>, <a href="https://www.mercurial-scm.org/" rel="noopener" target="_blank">Mercurial</a>, <a href="http://subversion.apache.org/" rel="noopener" target="_blank">Subversion</a>。一份用来跟踪代码所有修订版本的数据库被称作 <em>代码库</em>（code repository, code repo, repo）。</p><p>在类似 SVN 这样的集中式版本控制系统中，<em>基准代码</em> 就是指控制系统中的这一份代码库；而在 Git 那样的分布式版本控制系统中，<em>基准代码</em> 则是指最上游的那份代码库。</p><p>基准代码和应用之间总是保持一一对应的关系：</p><ul><li>一旦有多个基准代码，就不能称为一个应用，而是一个分布式系统。分布式系统中的每一个组件都是一个应用，每一个应用可以分别使用 12-Factor 进行开发。</li><li>多个应用共享一份基准代码是有悖于 12-Factor 原则的。解决方案是将共享的代码拆分为独立的类库，然后使用 <a href="https://12factor.net/zh_cn/dependencies" rel="noopener" target="_blank">依赖管理</a> 策略去加载它们。</li></ul><p>尽管每个应用只对应一份基准代码，但可以同时存在多份部署。每份 <em>部署</em> 相当于运行了一个应用的实例。通常会有一个生产环境，一个或多个预发布环境。此外，每个开发人员都会在自己本地环境运行一个应用实例，这些都相当于一份部署。</p><p>所有部署的基准代码相同，但每份部署可以使用其不同的版本。比如，开发人员可能有一些提交还没有同步至预发布环境；预发布环境也有一些提交没有同步至生产环境。但它们都共享一份基准代码，我们就认为它们只是相同应用的不同部署而已。</p><h2 id="II-依赖"><a href="#II-依赖" class="headerlink" title="II. 依赖"></a>II. 依赖</h2><blockquote><p>显式声明依赖关系（ dependency ）</p></blockquote><p>大多数编程语言都会提供一个打包系统，用来为各个类库提供打包服务，就像 Perl 的 <a href="http://www.cpan.org/" rel="noopener" target="_blank">CPAN</a> 或是 Ruby 的 <a href="http://rubygems.org/" rel="noopener" target="_blank">Rubygems</a> 。通过打包系统安装的类库可以是系统级的（称之为 “site packages”），或仅供某个应用程序使用，部署在相应的目录中（称之为 “vendoring” 或 “bunding”）。</p><p><strong>12-Factor规则下的应用程序不会隐式依赖系统级的类库。</strong> 它一定通过 <em>依赖清单</em> ，确切地声明所有依赖项。此外，在运行过程中通过 <em>依赖隔离</em> 工具来确保程序不会调用系统中存在但清单中未声明的依赖项。这一做法会统一应用到生产和开发环境。</p><p>例如， Ruby 的 <a href="https://bundler.io/" rel="noopener" target="_blank">Bundler</a> 使用 <code>Gemfile</code> 作为依赖项声明清单，使用 <code>bundle exec</code> 来进行依赖隔离。Python 中则可分别使用两种工具 – <a href="http://www.pip-installer.org/en/latest/" rel="noopener" target="_blank">Pip</a> 用作依赖声明， <a href="http://www.virtualenv.org/en/latest/" rel="noopener" target="_blank">Virtualenv</a> 用作依赖隔离。甚至 C 语言也有类似工具， <a href="http://www.gnu.org/s/autoconf/" rel="noopener" target="_blank">Autoconf</a> 用作依赖声明，静态链接库用作依赖隔离。无论用什么工具，依赖声明和依赖隔离必须一起使用，否则无法满足 12-Factor 规范。</p><p>显式声明依赖的优点之一是为新进开发者简化了环境配置流程。新进开发者可以检出应用程序的基准代码，安装编程语言环境和它对应的依赖管理工具，只需通过一个 <em>构建命令</em> 来安装所有的依赖项，即可开始工作。例如，Ruby/Bundler 下使用 <code>bundle install</code>，而 Clojure/<a href="https://github.com/technomancy/leiningen#readme" rel="noopener" target="_blank">Leiningen</a> 则是 <code>lein deps</code>。</p><p>12-Factor 应用同样不会隐式依赖某些系统工具，如 ImageMagick 或是<code>curl</code>。即使这些工具存在于几乎所有系统，但终究无法保证所有未来的系统都能支持应用顺利运行，或是能够和应用兼容。如果应用必须使用到某些系统工具，那么这些工具应该被包含在应用之中。</p><h2 id="III-配置"><a href="#III-配置" class="headerlink" title="III. 配置"></a>III. 配置</h2><blockquote><p>在环境中存储配置</p></blockquote><p>通常，应用的 <em>配置</em> 在不同 <a href="https://12factor.net/zh_cn/codebase" rel="noopener" target="_blank">部署</a> (预发布、生产环境、开发环境等等)间会有很大差异。这其中包括：</p><ul><li>数据库，Memcached，以及其他 <a href="https://12factor.net/zh_cn/backing-services" rel="noopener" target="_blank">后端服务</a> 的配置</li><li>第三方服务的证书，如 Amazon S3、Twitter 等</li><li>每份部署特有的配置，如域名等</li></ul><p>有些应用在代码中使用常量保存配置，这与 12-Factor 所要求的<strong>代码和配置严格分离</strong>显然大相径庭。配置文件在各部署间存在大幅差异，代码却完全一致。</p><p>判断一个应用是否正确地将配置排除在代码之外，一个简单的方法是看该应用的基准代码是否可以立刻开源，而不用担心会暴露任何敏感的信息。</p><p>需要指出的是，这里定义的“配置”并<strong>不</strong>包括应用的内部配置，比如 Rails 的 <code>config/routes.rb</code>，或是使用 <a href="http://spring.io/" rel="noopener" target="_blank">Spring</a> 时 <a href="http://docs.spring.io/spring/docs/current/spring-framework-reference/html/beans.html" rel="noopener" target="_blank">代码模块间的依赖注入关系</a> 。这类配置在不同部署间不存在差异，所以应该写入代码。</p><p>另外一个解决方法是使用配置文件，但不把它们纳入版本控制系统，就像 Rails 的 <code>config/database.yml</code> 。这相对于在代码中使用常量已经是长足进步，但仍然有缺点：总是会不小心将配置文件签入了代码库；配置文件的可能会分散在不同的目录，并有着不同的格式，这让找出一个地方来统一管理所有配置变的不太现实。更糟的是，这些格式通常是语言或框架特定的。</p><p><strong>12-Factor推荐将应用的配置存储于 <em>环境变量</em> 中</strong>（ <em>env vars</em>, <em>env</em> ）。环境变量可以非常方便地在不同的部署间做修改，却不动一行代码；与配置文件不同，不小心把它们签入代码库的概率微乎其微；与一些传统的解决配置问题的机制（比如 Java 的属性配置文件）相比，环境变量与语言和系统无关。</p><p>配置管理的另一个方面是分组。有时应用会将配置按照特定部署进行分组（或叫做“环境”），例如Rails中的 <code>development</code>,<code>test</code>, 和 <code>production</code> 环境。这种方法无法轻易扩展：更多部署意味着更多新的环境，例如 <code>staging</code> 或 <code>qa</code> 。 随着项目的不断深入，开发人员可能还会添加他们自己的环境，比如 <code>joes-staging</code> ，这将导致各种配置组合的激增，从而给管理部署增加了很多不确定因素。</p><p>12-Factor 应用中，环境变量的粒度要足够小，且相对独立。它们永远也不会组合成一个所谓的“环境”，而是独立存在于每个部署之中。当应用程序不断扩展，需要更多种类的部署时，这种配置管理方式能够做到平滑过渡。</p><h2 id="IV-后端服务"><a href="#IV-后端服务" class="headerlink" title="IV. 后端服务"></a>IV. 后端服务</h2><blockquote><p>把后端服务(backing services)当作附加资源</p></blockquote><p><em>后端服务</em>是指程序运行所需要的通过网络调用的各种服务，如数据库（<a href="http://dev.mysql.com/" rel="noopener" target="_blank">MySQL</a>，<a href="http://couchdb.apache.org/" rel="noopener" target="_blank">CouchDB</a>），消息/队列系统（<a href="http://www.rabbitmq.com/" rel="noopener" target="_blank">RabbitMQ</a>，<a href="https://beanstalkd.github.io/" rel="noopener" target="_blank">Beanstalkd</a>），SMTP 邮件发送服务（<a href="http://www.postfix.org/" rel="noopener" target="_blank">Postfix</a>），以及缓存系统（<a href="http://memcached.org/" rel="noopener" target="_blank">Memcached</a>）。</p><p>类似数据库的后端服务，通常由部署应用程序的系统管理员一起管理。除了本地服务之外，应用程序有可能使用了第三方发布和管理的服务。示例包括 SMTP（例如 <a href="http://postmarkapp.com/" rel="noopener" target="_blank">Postmark</a>），数据收集服务（例如 <a href="http://newrelic.com/" rel="noopener" target="_blank">New Relic</a> 或 <a href="http://www.loggly.com/" rel="noopener" target="_blank">Loggly</a>），数据存储服务（如 <a href="http://http//aws.amazon.com/s3/" rel="noopener" target="_blank">Amazon S3</a>），以及使用 API 访问的服务（例如 <a href="http://dev.twitter.com/" rel="noopener" target="_blank">Twitter</a>, <a href="https://developers.google.com/maps/" rel="noopener" target="_blank">Google Maps</a>, <a href="http://www.last.fm/api" rel="noopener" target="_blank">Last.fm</a>）。</p><p><strong>12-Factor 应用不会区别对待本地或第三方服务。</strong> 对应用程序而言，两种都是附加资源，通过一个 url 或是其他存储在 <a href="https://12factor.net/zh_cn/config" rel="noopener" target="_blank">配置</a> 中的服务定位/服务证书来获取数据。12-Factor 应用的任意 <a href="https://12factor.net/zh_cn/codebase" rel="noopener" target="_blank">部署</a> ，都应该可以在不进行任何代码改动的情况下，将本地 MySQL 数据库换成第三方服务（例如 <a href="http://aws.amazon.com/rds/" rel="noopener" target="_blank">Amazon RDS</a>）。类似的，本地 SMTP 服务应该也可以和第三方 SMTP 服务（例如 Postmark ）互换。上述 2 个例子中，仅需修改配置中的资源地址。</p><p>每个不同的后端服务是一份 <em>资源</em> 。例如，一个 MySQL 数据库是一个资源，两个 MySQL 数据库（用来数据分区）就被当作是 2 个不同的资源。12-Factor 应用将这些数据库都视作 <em>附加资源</em> ，这些资源和它们附属的部署保持松耦合。</p><p><img src="http://cdn.mjava.top/blog/kdvJQ2attached-resources.png" alt="https://12factor.net/images/attached-resources.png"></p><p>部署可以按需加载或卸载资源。例如，如果应用的数据库服务由于硬件问题出现异常，管理员可以从最近的备份中恢复一个数据库，卸载当前的数据库，然后加载新的数据库 – 整个过程都不需要修改代码。</p><h2 id="V-构建，发布，运行"><a href="#V-构建，发布，运行" class="headerlink" title="V. 构建，发布，运行"></a>V. 构建，发布，运行</h2><blockquote><p>严格分离构建和运行</p></blockquote><p><a href="https://12factor.net/zh_cn/codebase" rel="noopener" target="_blank">基准代码</a> 转化为一份部署(非开发环境)需要以下三个阶段：</p><ul><li><em>构建阶段</em> 是指将代码仓库转化为可执行包的过程。构建时会使用指定版本的代码，获取和打包 <a href="https://12factor.net/zh_cn/dependencies" rel="noopener" target="_blank">依赖项</a>，编译成二进制文件和资源文件。</li><li><em>发布阶段</em> 会将构建的结果和当前部署所需 <a href="https://12factor.net/zh_cn/config" rel="noopener" target="_blank">配置</a> 相结合，并能够立刻在运行环境中投入使用。</li><li><em>运行阶段</em> （或者说“运行时”）是指针对选定的发布版本，在执行环境中启动一系列应用程序 <a href="https://12factor.net/zh_cn/processes" rel="noopener" target="_blank">进程</a>。</li></ul><p><img src="http://cdn.mjava.top/blog/fC2jhRrelease.png" alt="https://12factor.net/images/release.png"></p><p><strong>12-factor 应用严格区分构建，发布，运行这三个步骤。</strong> 举例来说，直接修改处于运行状态的代码是非常不可取的做法，因为这些修改很难再同步回构建步骤。</p><p>部署工具通常都提供了发布管理工具，最引人注目的功能是退回至较旧的发布版本。比如， <a href="https://github.com/capistrano/capistrano/wiki" rel="noopener" target="_blank">Capistrano</a> 将所有发布版本都存储在一个叫 <code>releases</code> 的子目录中，当前的在线版本只需映射至对应的目录即可。该工具的 <code>rollback</code> 命令可以很容易地实现回退版本的功能。</p><p>每一个发布版本必须对应一个唯一的发布 ID，例如可以使用发布时的时间戳（<code>2011-04-06-20:32:17</code>），亦或是一个增长的数字（<code>v100</code>）。发布的版本就像一本只能追加的账本，一旦发布就不可修改，任何的变动都应该产生一个新的发布版本。</p><p>新的代码在部署之前，需要开发人员触发构建操作。但是，运行阶段不一定需要人为触发，而是可以自动进行。如服务器重启，或是进程管理器重启了一个崩溃的进程。因此，运行阶段应该保持尽可能少的模块，这样假设半夜发生系统故障而开发人员又捉襟见肘也不会引起太大问题。构建阶段是可以相对复杂一些的，因为错误信息能够立刻展示在开发人员面前，从而得到妥善处理。</p><h2 id="VI-进程"><a href="#VI-进程" class="headerlink" title="VI. 进程"></a>VI. 进程</h2><blockquote><p>以一个或多个无状态进程运行应用</p></blockquote><p>运行环境中，应用程序通常是以一个和多个 <em>进程</em> 运行的。</p><p>最简单的场景中，代码是一个独立的脚本，运行环境是开发人员自己的笔记本电脑，进程由一条命令行（例如<code>python my_script.py</code>）。另外一个极端情况是，复杂的应用可能会使用很多 <a href="https://12factor.net/zh_cn/concurrency" rel="noopener" target="_blank">进程类型</a> ，也就是零个或多个进程实例。</p><p><strong>12-Factor 应用的进程必须无状态且 <a href="http://en.wikipedia.org/wiki/Shared_nothing_architecture" rel="noopener" target="_blank">无共享</a> 。</strong> 任何需要持久化的数据都要存储在 <a href="https://12factor.net/zh_cn/backing-services" rel="noopener" target="_blank">后端服务</a> 内，比如数据库。</p><p>内存区域或磁盘空间可以作为进程在做某种事务型操作时的缓存，例如下载一个很大的文件，对其操作并将结果写入数据库的过程。12-Factor应用根本不用考虑这些缓存的内容是不是可以保留给之后的请求来使用，这是因为应用启动了多种类型的进程，将来的请求多半会由其他进程来服务。即使在只有一个进程的情形下，先前保存的数据（内存或文件系统中）也会因为重启（如代码部署、配置更改、或运行环境将进程调度至另一个物理区域执行）而丢失。</p><p>源文件打包工具（<a href="http://documentcloud.github.com/jammit/" rel="noopener" target="_blank">Jammit</a>, <a href="http://django-compressor.readthedocs.org/" rel="noopener" target="_blank">django-compressor</a>） 使用文件系统来缓存编译过的源文件。12-Factor 应用更倾向于在 <a href="https://12factor.net/zh_cn/build-release-run" rel="noopener" target="_blank">构建步骤</a> 做此动作——正如 <a href="http://guides.rubyonrails.org/asset_pipeline.html" rel="noopener" target="_blank">Rails资源管道</a> ，而不是在运行阶段。</p><p>一些互联网系统依赖于 “<a href="http://en.wikipedia.org/wiki/Load_balancing_%28computing%29#Persistence" rel="noopener" target="_blank">粘性 session</a>”， 这是指将用户 session 中的数据缓存至某进程的内存中，并将同一用户的后续请求路由到同一个进程。粘性 session 是 12-Factor 极力反对的。Session 中的数据应该保存在诸如 <a href="http://memcached.org/" rel="noopener" target="_blank">Memcached</a> 或 <a href="http://redis.io/" rel="noopener" target="_blank">Redis</a> 这样的带有过期时间的缓存中。</p><h2 id="VII-端口绑定"><a href="#VII-端口绑定" class="headerlink" title="VII. 端口绑定"></a>VII. 端口绑定</h2><blockquote><p>通过端口绑定(Port binding)来提供服务</p></blockquote><p>互联网应用有时会运行于服务器的容器之中。例如 PHP 经常作为 <a href="http://httpd.apache.org/" rel="noopener" target="_blank">Apache HTTPD</a> 的一个模块来运行，正如 Java 运行于 <a href="http://tomcat.apache.org/" rel="noopener" target="_blank">Tomcat</a> 。</p><p><strong>12-Factor 应用完全自我加载</strong> 而不依赖于任何网络服务器就可以创建一个面向网络的服务。互联网应用 <strong>通过端口绑定来提供服务</strong> ，并监听发送至该端口的请求。</p><p>本地环境中，开发人员通过类似<code>http://localhost:5000/</code>的地址来访问服务。在线上环境中，请求统一发送至公共域名而后路由至绑定了端口的网络进程。</p><p>通常的实现思路是，将网络服务器类库通过 <a href="https://12factor.net/zh_cn/dependencies" rel="noopener" target="_blank">依赖声明</a> 载入应用。例如，Python 的 <a href="http://www.tornadoweb.org/" rel="noopener" target="_blank">Tornado</a>, Ruby 的<a href="http://code.macournoyer.com/thin/" rel="noopener" target="_blank">Thin</a> , Java 以及其他基于 JVM 语言的 <a href="http://www.eclipse.org/jetty/" rel="noopener" target="_blank">Jetty</a>。完全由 <em>用户端</em> ，确切的说应该是应用的代码，发起请求。和运行环境约定好绑定的端口即可处理这些请求。</p><p>HTTP 并不是唯一一个可以由端口绑定提供的服务。其实几乎所有服务器软件都可以通过进程绑定端口来等待请求。例如，使用 <a href="http://xmpp.org/" rel="noopener" target="_blank">XMPP</a> 的 <a href="http://www.ejabberd.im/" rel="noopener" target="_blank">ejabberd</a> ， 以及使用 <a href="http://redis.io/topics/protocol" rel="noopener" target="_blank">Redis 协议</a> 的 <a href="http://redis.io/" rel="noopener" target="_blank">Redis</a> 。</p><p>还要指出的是，端口绑定这种方式也意味着一个应用可以成为另外一个应用的 <a href="https://12factor.net/zh_cn/backing-services" rel="noopener" target="_blank">后端服务</a> ，调用方将服务方提供的相应 URL 当作资源存入 <a href="https://12factor.net/zh_cn/config" rel="noopener" target="_blank">配置</a> 以备将来调用。</p><h2 id="VIII-并发"><a href="#VIII-并发" class="headerlink" title="VIII. 并发"></a>VIII. 并发</h2><blockquote><p>通过进程模型进行扩展</p></blockquote><p>任何计算机程序，一旦启动，就会生成一个或多个进程。互联网应用采用多种进程运行方式。例如，PHP 进程作为 Apache 的子进程存在，随请求按需启动。Java 进程则采取了相反的方式，在程序启动之初 JVM 就提供了一个超级进程储备了大量的系统资源(CPU 和内存)，并通过多线程实现内部的并发管理。上述 2 个例子中，进程是开发人员可以操作的最小单位。</p><p><img src="http://cdn.mjava.top/blog/531PHlprocess-types.png" alt="https://12factor.net/images/process-types.png"></p><p><strong>在 12-factor 应用中，进程是一等公民。</strong>12-Factor 应用的进程主要借鉴于 <a href="https://adam.herokuapp.com/past/2011/5/9/applying_the_unix_process_model_to_web_apps/" rel="noopener" target="_blank">unix 守护进程模型</a> 。开发人员可以运用这个模型去设计应用架构，将不同的工作分配给不同的 <em>进程类型</em> 。例如，HTTP 请求可以交给 web 进程来处理，而常驻的后台工作则交由 worker 进程负责。</p><p>这并不包括个别较为特殊的进程，例如通过虚拟机的线程处理并发的内部运算，或是使用诸如 <a href="https://github.com/eventmachine/eventmachine" rel="noopener" target="_blank">EventMachine</a>, <a href="http://twistedmatrix.com/trac/" rel="noopener" target="_blank">Twisted</a>, <a href="http://nodejs.org/" rel="noopener" target="_blank">Node.js</a> 的异步/事件触发模型。但一台独立的虚拟机的扩展有瓶颈（垂直扩展），所以应用程序必须可以在多台物理机器间跨进程工作。</p><p>上述进程模型会在系统急需扩展时大放异彩。 <a href="https://12factor.net/zh_cn/processes" rel="noopener" target="_blank">12-Factor 应用的进程所具备的无共享，水平分区的特性</a> 意味着添加并发会变得简单而稳妥。这些进程的类型以及每个类型中进程的数量就被称作 <em>进程构成</em> 。</p><p>12-Factor 应用的进程 <a href="http://dustin.github.com/2010/02/28/running-processes.html" rel="noopener" target="_blank">不需要守护进程</a> 或是写入 PID 文件。相反的，应该借助操作系统的进程管理器(例如 <a href="https://www.freedesktop.org/wiki/Software/systemd/" rel="noopener" target="_blank">systemd</a> ，分布式的进程管理云平台，或是类似 <a href="http://blog.daviddollar.org/2011/05/06/introducing-foreman.html" rel="noopener" target="_blank">Foreman</a> 的工具)，来管理 <a href="https://12factor.net/zh_cn/logs" rel="noopener" target="_blank">输出流</a> ，响应崩溃的进程，以及处理用户触发的重启和关闭超级进程的请求。</p><h2 id="IX-易处理"><a href="#IX-易处理" class="headerlink" title="IX. 易处理"></a>IX. 易处理</h2><blockquote><p>快速启动和优雅终止可最大化健壮性</p></blockquote><p><strong>12-Factor 应用的 <a href="https://12factor.net/zh_cn/processes" rel="noopener" target="_blank">进程</a> 是 <em>易处理（disposable）</em>的，意思是说它们可以瞬间开启或停止。</strong> 这有利于快速、弹性的伸缩应用，迅速部署变化的 <a href="https://12factor.net/zh_cn/codebase" rel="noopener" target="_blank">代码</a> 或 <a href="https://12factor.net/zh_cn/config" rel="noopener" target="_blank">配置</a> ，稳健的部署应用。</p><p>进程应当追求 <strong>最小启动时间</strong> 。 理想状态下，进程从敲下命令到真正启动并等待请求的时间应该只需很短的时间。更少的启动时间提供了更敏捷的 <a href="https://12factor.net/zh_cn/build-release-run" rel="noopener" target="_blank">发布</a> 以及扩展过程，此外还增加了健壮性，因为进程管理器可以在授权情形下容易的将进程搬到新的物理机器上。</p><p>进程 <strong>一旦接收 <a href="http://en.wikipedia.org/wiki/SIGTERM" rel="noopener" target="_blank">终止信号（<code>SIGTERM</code>）</a> 就会优雅的终止</strong> 。就网络进程而言，优雅终止是指停止监听服务的端口，即拒绝所有新的请求，并继续执行当前已接收的请求，然后退出。此类型的进程所隐含的要求是HTTP请求大多都很短(不会超过几秒钟)，而在长时间轮询中，客户端在丢失连接后应该马上尝试重连。</p><p>对于 worker 进程来说，优雅终止是指将当前任务退回队列。例如，<a href="http://www.rabbitmq.com/" rel="noopener" target="_blank">RabbitMQ</a> 中，worker 可以发送一个<code>[NACK](http://www.rabbitmq.com/amqp-0-9-1-quickref.html#basic.nack)</code>信号。 <a href="https://beanstalkd.github.io/" rel="noopener" target="_blank">Beanstalkd</a> 中，任务终止并退回队列会在worker断开时自动触发。有锁机制的系统诸如 <a href="https://github.com/collectiveidea/delayed_job#readme" rel="noopener" target="_blank">Delayed Job</a> 则需要确定释放了系统资源。此类型的进程所隐含的要求是，任务都应该 <a href="http://en.wikipedia.org/wiki/Reentrant_%28subroutine%29" rel="noopener" target="_blank">可重复执行</a> ， 这主要由将结果包装进事务或是使重复操作 <a href="http://en.wikipedia.org/wiki/Idempotence" rel="noopener" target="_blank">幂等</a> 来实现。</p><p>进程还应当<strong>在面对突然死亡时保持健壮</strong>，例如底层硬件故障。虽然这种情况比起优雅终止来说少之又少，但终究有可能发生。一种推荐的方式是使用一个健壮的后端队列，例如 <a href="https://beanstalkd.github.io/" rel="noopener" target="_blank">Beanstalkd</a> ，它可以在客户端断开或超时后自动退回任务。无论如何，12-Factor 应用都应该可以设计能够应对意外的、不优雅的终结。<a href="http://lwn.net/Articles/191059/" rel="noopener" target="_blank">Crash-only design</a> 将这种概念转化为 <a href="http://couchdb.apache.org/docs/overview.html" rel="noopener" target="_blank">合乎逻辑的理论</a>。</p><h2 id="X-开发环境与线上环境等价"><a href="#X-开发环境与线上环境等价" class="headerlink" title="X. 开发环境与线上环境等价"></a>X. 开发环境与线上环境等价</h2><blockquote><p>尽可能的保持开发，预发布，线上环境相同</p></blockquote><p>从以往经验来看，开发环境（即开发人员的本地 <a href="https://12factor.net/zh_cn/codebase" rel="noopener" target="_blank">部署</a>）和线上环境（外部用户访问的真实部署）之间存在着很多差异。这些差异表现在以下三个方面：</p><ul><li><strong>时间差异：</strong> 开发人员正在编写的代码可能需要几天，几周，甚至几个月才会上线。</li><li><strong>人员差异：</strong> 开发人员编写代码，运维人员部署代码。</li><li><strong>工具差异：</strong> 开发人员或许使用 Nginx，SQLite，OS X，而线上环境使用 Apache，MySQL 以及 Linux。</li></ul><p><strong>12-Factor 应用想要做到 <a href="http://avc.com/2011/02/continuous-deployment/" rel="noopener" target="_blank">持续部署</a> 就必须缩小本地与线上差异。</strong> 再回头看上面所描述的三个差异:</p><ul><li>缩小时间差异：开发人员可以几小时，甚至几分钟就部署代码。</li><li>缩小人员差异：开发人员不只要编写代码，更应该密切参与部署过程以及代码在线上的表现。</li><li>缩小工具差异：尽量保证开发环境以及线上环境的一致性。</li></ul><p>将上述总结变为一个表格如下：</p><table><thead><tr><th></th><th>传统应用</th><th>12-Factor 应用</th></tr></thead><tbody><tr><td>每次部署间隔</td><td>数周</td><td>几小时</td></tr><tr><td>开发人员 vs 运维人员</td><td>不同的人</td><td>相同的人</td></tr><tr><td>开发环境 vs 线上环境</td><td>不同</td><td>尽量接近</td></tr></tbody></table><p><a href="https://12factor.net/zh_cn/backing-services" rel="noopener" target="_blank">后端服务</a> 是保持开发与线上等价的重要部分，例如数据库，队列系统，以及缓存。许多语言都提供了简化获取后端服务的类库，例如不同类型服务的 <em>适配器</em> 。下列表格提供了一些例子。</p><table><thead><tr><th>类型</th><th>语言</th><th>类库</th><th>适配器</th></tr></thead><tbody><tr><td>数据库</td><td>Ruby/Rails</td><td>ActiveRecord</td><td>MySQL, PostgreSQL, SQLite</td></tr><tr><td>队列</td><td>Python/Django</td><td>Celery</td><td>RabbitMQ, Beanstalkd, Redis</td></tr><tr><td>缓存</td><td>Ruby/Rails</td><td>ActiveSupport::Cache</td><td>Memory, filesystem, Memcached</td></tr></tbody></table><p>开发人员有时会觉得在本地环境中使用轻量的后端服务具有很强的吸引力，而那些更重量级的健壮的后端服务应该使用在生产环境。例如，本地使用 SQLite 线上使用 PostgreSQL；又如本地缓存在进程内存中而线上存入 Memcached。</p><p><strong>12-Factor 应用的开发人员应该反对在不同环境间使用不同的后端服务</strong> ，即使适配器已经可以几乎消除使用上的差异。这是因为，不同的后端服务意味着会突然出现的不兼容，从而导致测试、预发布都正常的代码在线上出现问题。这些错误会给持续部署带来阻力。从应用程序的生命周期来看，消除这种阻力需要花费很大的代价。</p><p>与此同时，轻量的本地服务也不像以前那样引人注目。借助于<a href="http://mxcl.github.com/homebrew/" rel="noopener" target="_blank">Homebrew</a>，<a href="https://help.ubuntu.com/community/AptGet/Howto" rel="noopener" target="_blank">apt-get</a>等现代的打包系统，诸如Memcached、PostgreSQL、RabbitMQ 等后端服务的安装与运行也并不复杂。此外，使用类似 <a href="http://www.opscode.com/chef/" rel="noopener" target="_blank">Chef</a> 和 <a href="http://docs.puppetlabs.com/" rel="noopener" target="_blank">Puppet</a> 的声明式配置工具，结合像 <a href="http://vagrantup.com/" rel="noopener" target="_blank">Vagrant</a> 这样轻量的虚拟环境就可以使得开发人员的本地环境与线上环境无限接近。与同步环境和持续部署所带来的益处相比，安装这些系统显然是值得的。</p><p>不同后端服务的适配器仍然是有用的，因为它们可以使移植后端服务变得简单。但应用的所有部署，这其中包括开发、预发布以及线上环境，都应该使用同一个后端服务的相同版本。</p><h2 id="XI-日志"><a href="#XI-日志" class="headerlink" title="XI. 日志"></a>XI. 日志</h2><blockquote><p>把日志当作事件流</p></blockquote><p><em>日志</em> 使得应用程序运行的动作变得透明。在基于服务器的环境中，日志通常被写在硬盘的一个文件里，但这只是一种输出格式。</p><p>日志应该是 <a href="https://adam.herokuapp.com/past/2011/4/1/logs_are_streams_not_files/" rel="noopener" target="_blank">事件流</a> 的汇总，将所有运行中进程和后端服务的输出流按照时间顺序收集起来。尽管在回溯问题时可能需要看很多行，日志最原始的格式确实是一个事件一行。日志没有确定开始和结束，但随着应用在运行会持续的增加。</p><p><strong>12-factor应用本身从不考虑存储自己的输出流。</strong> 不应该试图去写或者管理日志文件。相反，每一个运行的进程都会直接的标准输出（<code>stdout</code>）事件流。开发环境中，开发人员可以通过这些数据流，实时在终端看到应用的活动。</p><p>在预发布或线上部署中，每个进程的输出流由运行环境截获，并将其他输出流整理在一起，然后一并发送给一个或多个最终的处理程序，用于查看或是长期存档。这些存档路径对于应用来说不可见也不可配置，而是完全交给程序的运行环境管理。类似 <a href="https://github.com/heroku/logplex" rel="noopener" target="_blank">Logplex</a> 和 <a href="https://github.com/fluent/fluentd" rel="noopener" target="_blank">Fluentd</a> 的开源工具可以达到这个目的。</p><p>这些事件流可以输出至文件，或者在终端实时观察。最重要的，输出流可以发送到 <a href="http://www.splunk.com/" rel="noopener" target="_blank">Splunk</a> 这样的日志索引及分析系统，或 <a href="http://hive.apache.org/" rel="noopener" target="_blank">Hadoop/Hive</a> 这样的通用数据存储系统。这些系统为查看应用的历史活动提供了强大而灵活的功能，包括：</p><ul><li>找出过去一段时间特殊的事件。</li><li>图形化一个大规模的趋势，比如每分钟的请求量。</li><li>根据用户定义的条件实时触发警报，比如每分钟的报错超过某个警戒线。</li></ul><h2 id="XII-管理进程"><a href="#XII-管理进程" class="headerlink" title="XII. 管理进程"></a>XII. 管理进程</h2><blockquote><p>后台管理任务当作一次性进程运行</p></blockquote><p><a href="https://12factor.net/zh_cn/concurrency" rel="noopener" target="_blank">进程构成</a>（process formation）是指用来处理应用的常规业务（比如处理 web 请求）的一组进程。与此不同，开发人员经常希望执行一些管理或维护应用的一次性任务，例如：</p><ul><li>运行数据移植（Django 中的 <code>manage.py migrate</code>, Rails 中的 <code>rake db:migrate</code>）。</li><li>运行一个控制台（也被称为 <a href="http://en.wikipedia.org/wiki/Read-eval-print_loop" rel="noopener" target="_blank">REPL</a> shell），来执行一些代码或是针对线上数据库做一些检查。大多数语言都通过解释器提供了一个 REPL 工具（<code>python</code> 或 <code>perl</code>） ，或是其他命令（Ruby 使用 <code>irb</code>, Rails 使用 <code>rails console</code>）。</li><li>运行一些提交到代码仓库的一次性脚本。</li></ul><p>一次性管理进程应该和正常的 <a href="https://12factor.net/zh_cn/processes" rel="noopener" target="_blank">常驻进程</a> 使用同样的环境。这些管理进程和任何其他的进程一样使用相同的 <a href="https://12factor.net/zh_cn/codebase" rel="noopener" target="_blank">代码</a> 和 <a href="https://12factor.net/zh_cn/config" rel="noopener" target="_blank">配置</a> ，基于某个 <a href="https://12factor.net/zh_cn/build-release-run" rel="noopener" target="_blank">发布版本</a> 运行。后台管理代码应该随其他应用程序代码一起发布，从而避免同步问题。</p><p>所有进程类型应该使用同样的 <a href="https://12factor.net/zh_cn/dependencies" rel="noopener" target="_blank">依赖隔离</a> 技术。例如，如果Ruby的web进程使用了命令 <code>bundle exec thin start</code> ，那么数据库移植应使用 <code>bundle exec rake db:migrate</code> 。同样的，如果一个 Python 程序使用了 Virtualenv，则需要在运行 Tornado Web 服务器和任何 <code>manage.py</code> 管理进程时引入 <code>bin/python</code> 。</p><p>12-factor 尤其青睐那些提供了 REPL shell 的语言，因为那会让运行一次性脚本变得简单。在本地部署中，开发人员直接在命令行使用 shell 命令调用一次性管理进程。在线上部署中，开发人员依旧可以使用ssh或是运行环境提供的其他机制来运行这样的进程。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;开发SaaS应用的12条准则【转】&quot;&gt;&lt;a href=&quot;#开发SaaS应用的12条准则【转】&quot; class=&quot;headerlink&quot; title=&quot;开发SaaS应用的12条准则【转】&quot;&gt;&lt;/a&gt;开发SaaS应用的12条准则【转】&lt;/h1&gt;&lt;blockquote&gt;

      
    
    </summary>
    
    
    
      <category term="SaaS" scheme="http://blog.mjava.top/tags/SaaS/"/>
    
  </entry>
  
  <entry>
    <title>vertx的web开发学习笔记</title>
    <link href="http://blog.mjava.top/vertx/10EF2E95447C468CB55BD7BD0675C090/"/>
    <id>http://blog.mjava.top/vertx/10EF2E95447C468CB55BD7BD0675C090/</id>
    <published>2021-07-05T15:31:02.000Z</published>
    <updated>2021-07-22T03:30:13.223Z</updated>
    
    <content type="html"><![CDATA[<h2 id="创建一个-Http-服务"><a href="#创建一个-Http-服务" class="headerlink" title="创建一个 Http 服务"></a>创建一个 Http 服务</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建路由</span></span><br><span class="line">Router router = Router.router(vertx);</span><br><span class="line"><span class="comment">// 创建 Http 服务</span></span><br><span class="line">vertx.createHttpServer()</span><br><span class="line">  <span class="comment">// 绑定路由</span></span><br><span class="line">  .requestHandler(router)</span><br><span class="line">  <span class="comment">// 监听端口</span></span><br><span class="line">  .listen(<span class="number">8888</span>)</span><br><span class="line">  <span class="comment">// Http 服务启动成功后调用</span></span><br><span class="line">  .onSuccess(server -&gt;</span><br><span class="line">   System.out.println(<span class="string">"HTTP server started on port "</span> + server.actualPort())</span><br><span class="line">   );</span><br></pre></td></tr></table></figure><h2 id="Router-使用"><a href="#Router-使用" class="headerlink" title="Router 使用"></a>Router 使用</h2><blockquote><p>直接使用上面的路由实例</p></blockquote><h3 id="创建请求路由"><a href="#创建请求路由" class="headerlink" title="创建请求路由"></a>创建请求路由</h3><ul><li><p>创建 Get 请求路由</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">router</span><br><span class="line">  .get(<span class="string">"/test"</span>)</span><br><span class="line">  .respond(</span><br><span class="line">    <span class="comment">// 响应逻辑</span></span><br><span class="line">  )</span><br><span class="line">  </span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line">router</span><br><span class="line">  .route(HttpMethod.GET, <span class="string">"/test"</span>)</span><br><span class="line">  .respond(</span><br><span class="line">    <span class="comment">// 响应逻辑</span></span><br><span class="line">  )</span><br></pre></td></tr></table></figure></li><li><p>创建 Post 请求路由</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">router</span><br><span class="line">  .post(<span class="string">"/test"</span>)</span><br><span class="line">  .respond(</span><br><span class="line"><span class="comment">// 响应逻辑</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line">router</span><br><span class="line">  .post(HttpMethod.POST, <span class="string">"/test"</span>)</span><br><span class="line">  .respond(</span><br><span class="line"><span class="comment">// 响应逻辑</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure></li></ul><h3 id="获取参数"><a href="#获取参数" class="headerlink" title="获取参数"></a>获取参数</h3><ul><li><p>获取 URL 参数</p><blockquote><p>请求地址示例：<a href="http://localhost:8080/get?param=greycode" rel="noopener" target="_blank">http://localhost:8080/get?param=greycode</a></p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">router.get(<span class="string">"/get"</span>).handler(context-&gt; </span><br><span class="line">&#123;</span><br><span class="line">String param = context.request().getParam(<span class="string">"param"</span>);</span><br><span class="line">System.out.println(param);</span><br><span class="line">&#125;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 控制台打印</span></span><br><span class="line">greycode</span><br></pre></td></tr></table></figure></li><li><p>获取 REST 风格的地址参数</p><blockquote><p>请求地址示例：<a href="http://localhost:8080/get/greycode" rel="noopener" target="_blank">http://localhost:8080/get/greycode</a></p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">router.get(<span class="string">"/get/:param"</span>).handler(context-&gt; </span><br><span class="line">&#123;</span><br><span class="line">String param = context.pathParam(<span class="string">"param"</span>);</span><br><span class="line">System.out.println(param);</span><br><span class="line">&#125;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 控制台打印</span></span><br><span class="line">greycode</span><br></pre></td></tr></table></figure></li><li><p>获取  Body 数据</p><blockquote><p>请求地址示例：<a href="http://localhost:8080/post" rel="noopener" target="_blank">http://localhost:8080/post</a>    </p><p>请求数据：</p><figure class="highlight"><table><tr><td class="code"><pre><span class="line">&gt; &#123;</span><br><span class="line">&gt;  "name":"greycode"</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在获取数据前，一定要执行这行代码</span></span><br><span class="line"><span class="comment">// 否则就会报：警告: BodyHandler in not enabled on this route: RoutingContext.getBodyAsJson() in always be NULL‘</span></span><br><span class="line">router.route().handler(BodyHandler.create());</span><br><span class="line"></span><br><span class="line">router.post(<span class="string">"/post"</span>).handler(context-&gt;&#123;</span><br><span class="line">  JsonObject body = context.getBodyAsJson();</span><br><span class="line">  System.out.println(body.toString());</span><br><span class="line">&#125;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 控制台打印</span></span><br><span class="line">&#123;<span class="string">"name"</span>:<span class="string">"greycode"</span>&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">router.get(<span class="string">"/get"</span>).handler(context-&gt;</span><br><span class="line">  &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"模拟错误"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">)</span><br><span class="line">.failureHandler(context-&gt; &#123;</span><br><span class="line">    <span class="comment">// 发生异常时执行的代码</span></span><br><span class="line">  &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;创建一个-Http-服务&quot;&gt;&lt;a href=&quot;#创建一个-Http-服务&quot; class=&quot;headerlink&quot; title=&quot;创建一个 Http 服务&quot;&gt;&lt;/a&gt;创建一个 Http 服务&lt;/h2&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;t
      
    
    </summary>
    
    
      <category term="Vert.x" scheme="http://blog.mjava.top/categories/Vert-x/"/>
    
    
      <category term="Vert.x" scheme="http://blog.mjava.top/tags/Vert-x/"/>
    
  </entry>
  
  <entry>
    <title>Java删除文件后电脑磁盘空间没有恢复</title>
    <link href="http://blog.mjava.top/java/74CAAAFD610241A1B8ECDB5F3BB33EE4/"/>
    <id>http://blog.mjava.top/java/74CAAAFD610241A1B8ECDB5F3BB33EE4/</id>
    <published>2021-07-03T17:12:41.000Z</published>
    <updated>2021-07-22T03:30:13.219Z</updated>
    
    <content type="html"><![CDATA[<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>当用一下命令删除文件后，电脑磁盘内存没有恢复，还是原来的大小</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">File folder = <span class="keyword">new</span> File(<span class="string">"/tmp/file.mp4"</span>)</span><br><span class="line">file.delete();</span><br></pre></td></tr></table></figure><h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><p>原来是 <code>FileOutputStream</code> 文件流忘了关了，导致一直占用这个资源。所以使用完后一定记得关文件流，使用下面的代码关闭文件流：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">FileOutputStream fileOutputStream = <span class="keyword">new</span> FileOutputStream(<span class="keyword">new</span> File());</span><br><span class="line">fileOutputStream.close();</span><br></pre></td></tr></table></figure><p><strong>Linux 里的文件被删除后，空间没有被释放是因为在 Linux 系统中，通过 rm 或者文件管理器删除文件将会从文件系统的目录结构上解除链接(unlink).然而如果文件是被打开的(有一个进程正在使用)，那么进程将仍然可以读取该文件，磁盘空间也一直被占用。</strong></p><p>可以使用 <code>lsof +L1 |grep delete</code> 命令来查看状态为 <code>deleted</code> 的文件，状态为 <code>deleted</code> 为标记被删除，其实该文件并没有从磁盘中删除，类似windows下的回收站状态。</p><p>所以当进程结束后，磁盘空间就会被释放。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="http://www.cxyzjd.com/article/su4416160/78212934" rel="noopener" target="_blank">http://www.cxyzjd.com/article/su4416160/78212934</a></li><li><a href="https://www.jianshu.com/p/fcb80c878d04" rel="noopener" target="_blank">https://www.jianshu.com/p/fcb80c878d04</a></li></ul>]]></content>
    
    <summary type="html">
    
      当用一下命令删除文件后，电脑磁盘内存没有恢复，还是原来的大小
    
    </summary>
    
    
      <category term="Java" scheme="http://blog.mjava.top/categories/Java/"/>
    
    
      <category term="Java" scheme="http://blog.mjava.top/tags/Java/"/>
    
      <category term="Linux" scheme="http://blog.mjava.top/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>程序员的酒后真言</title>
    <link href="http://blog.mjava.top/archive/essay/A98D5EC3509F483E80919CA2E09BDA1B/"/>
    <id>http://blog.mjava.top/archive/essay/A98D5EC3509F483E80919CA2E09BDA1B/</id>
    <published>2021-06-29T11:24:25.000Z</published>
    <updated>2021-07-22T03:30:13.219Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>转至：<a href="http://www.ruanyifeng.com/blog/2021/06/drunk-post-of-a-programmer.html" rel="noopener" target="_blank">http://www.ruanyifeng.com/blog/2021/06/drunk-post-of-a-programmer.html</a></p><p>出至：<a href="https://old.reddit.com/r/ExperiencedDevs/comments/nmodyl/drunk_post_things_ive_learned_as_a_sr_engineer/" rel="noopener" target="_blank">https://old.reddit.com/r/ExperiencedDevs/comments/nmodyl/drunk_post_things_ive_learned_as_a_sr_engineer/</a></p></blockquote><p>(1) 职业发展的最好方法是换公司。</p><p>(2）技术栈不重要。技术领域有大约 10-20 条核心原则，重要的是这些原则，技术栈只是落实它们的方法。你如果不熟悉某个技术栈，不需要过度担心。</p><p>(3）工作和人际关系是两回事。有一些公司，我交到了好朋友，但是工作得并不开心；另一些公司，我没有与任何同事建立友谊，但是工作得很开心。</p><p>(4）我总是对经理实话实说。怕什么？他开除我？我会在两周内找到一份新工作。</p><p>(5）如果一家公司的工程师超过 100 人，它的期权可能在未来十年内变得很有价值。对于工程师人数很少的公司，期权一般都是毫无价值。</p><p>(6）好的代码是初级工程师可以理解的代码。伟大的代码可以被第一年的 CS 专业的新生理解。</p><p>(7）作为一名工程师，最被低估的技能是记录。说真的，如果有人可以教我怎么写文档，我会付钱，也许是 1000 美元。</p><p>(8）网上的口水战，几乎都无关紧要，别去参与。</p><p>(9）如果我发现自己是公司里面最厉害的工程师，那就该离开了。</p><p>(10）我们应该雇佣更多的实习生，他们很棒。那些精力充沛的小家伙用他们的想法乱搞。如果他们公开质疑或批评某事，那就更好了。我喜欢实习生。</p><p>(11）技术栈很重要。如果你使用 Python 或 C++ 语言，就会忍不住想做一些非常不同的事情。因为某些工具确实擅长某些工作。</p><p>(12）如果你不确定自己想做什么东西，请使用 Java。这是一种糟糕的编程语言，但几乎无所不能。</p><p>(13）对于初学者来说，最赚钱的编程语言是 SQL，干翻所有其他语言。你只了解 SQL 而不会做其他事情，照样赚钱。人力资源专家的年薪？也许5万美元。懂 SQL 的人力资源专家？9万美元。</p><p>(14）测试很重要，但 TDD （测试驱动的开发）几乎变成了一个邪教。</p><p>(15） 政府单位很轻松，但并不像人们说的那样好。对于职业生涯早期到中期的工程师，12 万美元的年薪 + 各种福利 + 养老金听起来不错，但是你将被禁锢在深奥的专用工具里面，离开政府单位以后，这些知识就没用了。我非常尊重政府工作人员，但说真的，这些地方的工程师，年龄中位数在 50 岁以上是有原因的。</p><p>(16）再倒一杯酒。</p><p>(17）大多数头衔都无关紧要，随便什么公司都可以有首席工程师。</p><p>(18）手腕和背部的健康问题可不是开玩笑的，好的设备值得花钱。</p><p>(19）当一个软件工程师，最好的事情是什么？你可以结识很多想法相同的人，大家互相交流，不一定有相同的兴趣，但是对方会用跟你相同的方式思考问题，这很酷。</p><p>(20）有些技术太流行，我不得不用它。我心里就会很讨厌这种技术，但会把它推荐给客户，比如我恨 Jenkins，但把它推荐给新客户，我不觉得做错了。</p><p>(21）成为一名优秀的工程师意味着了解最佳实践，成为高级工程师意味着知道何时打破最佳实践。</p><p>(22）发生事故时，如果周围的人试图将责任归咎于外部错误或底层服务中断，那么是时候离开这家公司，继续前进了。</p><p>(23）我遇到的最好的领导，同意我的一部分观点，同时耐心跟我解释，为什么不同意我的另一部分观点。我正在努力成为像他们一样的人。</p><p>(24）算法和数据结构确实重要，但不应该无限夸大，尤其是面试的时候。我没见过药剂师面试时，还要测试有机化学的细节。这个行业的面试过程有时候很糟糕。</p><p>(25）做自己喜欢的事情并不重要，不要让我做讨厌的事情更重要。</p><p>(26）越接近产品，就越接近推动收入增长。无论工作的技术性如何，只要它接近产品，我都感到越有价值。</p><p>(27）即使我平时用 Windows 工作，Linux 也很重要。为什么？因为服务器是 Linux 系统，你最终在 Linux 系统上工作。</p><p>(28）人死了以后，你想让代码成为你的遗产吗？如果是那样，就花很多时间在代码上面吧，因为那是你的遗产。但是，如果你像我一样，更看重与家人、朋友和生活中其他人相处的时光，而不是写的代码，那就别对它太在意。</p><p>(29）我挣的钱还不错，对此心存感激，但还是需要省钱。</p><p>(30）糟糕，我没酒了。</p><p>(完）</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;转至：&lt;a href=&quot;http://www.ruanyifeng.com/blog/2021/06/drunk-post-of-a-programmer.html&quot; rel=&quot;noopener&quot; target=&quot;_blank&quot;&gt;http://ww
      
    
    </summary>
    
    
      <category term="Essay" scheme="http://blog.mjava.top/categories/Essay/"/>
    
    
      <category term="闲谈" scheme="http://blog.mjava.top/tags/%E9%97%B2%E8%B0%88/"/>
    
  </entry>
  
  <entry>
    <title>免费全自动SEO优化</title>
    <link href="http://blog.mjava.top/tool/21324399FBDC41CBA815D2069BB62168/"/>
    <id>http://blog.mjava.top/tool/21324399FBDC41CBA815D2069BB62168/</id>
    <published>2021-06-20T22:27:32.000Z</published>
    <updated>2021-07-22T03:30:13.223Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x1-简介"><a href="#0x1-简介" class="headerlink" title="0x1 简介"></a>0x1 简介</h2><p>怎么让各大站长快速收录你自己网站的链接？那就是主动的推送你自己网站的 URL 到各大站长上去。前几天我写了一个一键提交的工具，可以一键提交你的链接到各大站长上去。你也可以单独使用工具来推送你的 URL、批量 URL 文件、SiteMap 站点地图。工具的github地址是：<a href="https://github.com/greycodee/seo-tools" rel="noopener" target="_blank">https://github.com/greycodee/seo-tools</a></p><p><img src="http://cdn.mjava.top/blog/Nee81Aimage-20210620211932651.png" alt="image-20210620211932651"> </p><p>今天我再教大家如何让网站自动提交最新的 URL 到各大站长上去，让各大站长第一时间收录你的链接。</p><h2 id="0x2-准备"><a href="#0x2-准备" class="headerlink" title="0x2 准备"></a>0x2 准备</h2><p>在开始前，你需要准备如下东西：</p><ul><li><p><a href="https://ifttt.com/home" rel="noopener" target="_blank">IFTTT</a> 账号</p></li><li><p><a href="https://github.com/" rel="noopener" target="_blank">Github</a> 账号</p></li><li><p>你个人网站开通 RSS 订阅</p></li></ul><p>具体原理就是通过 IFTTT 订阅你网站的 RSS，然后当有新的网址发布后，IFTTT 会触发事件回调 Github，Github 收到回调后 Github Action 会进行运转，然后在里面使用工具进行推送。</p><p><img src="http://cdn.mjava.top/blog/1h6Cpuseo%E8%87%AA%E5%8A%A8%E6%8F%90%E4%BA%A4.png" alt="seo自动提交"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;0x1-简介&quot;&gt;&lt;a href=&quot;#0x1-简介&quot; class=&quot;headerlink&quot; title=&quot;0x1 简介&quot;&gt;&lt;/a&gt;0x1 简介&lt;/h2&gt;&lt;p&gt;怎么让各大站长快速收录你自己网站的链接？那就是主动的推送你自己网站的 URL 到各大站长上去。前几天我写了一
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>百度、谷歌、必应三大站长API密钥申请流程</title>
    <link href="http://blog.mjava.top/tool/C334612CBDCE41E79F7EA6A2F3F4C10C/"/>
    <id>http://blog.mjava.top/tool/C334612CBDCE41E79F7EA6A2F3F4C10C/</id>
    <published>2021-06-17T21:40:11.000Z</published>
    <updated>2021-07-22T03:30:13.223Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Google-索引-API-开通步骤"><a href="#Google-索引-API-开通步骤" class="headerlink" title="Google 索引 API 开通步骤"></a>Google 索引 API 开通步骤</h2><ol><li><p>点击此<a href="https://console.cloud.google.com/flows/enableapi?apiid=indexing.googleapis.com&;credential=client_key&hl=zh-cn" rel="noopener" target="_blank">链接</a>，然后选择<strong>创建项目</strong>，点击继续。然后再点击<strong>转到“凭据”页面</strong></p><p><img src="http://cdn.mjava.top/blog/pFDIcIimage-20210616142818704.png" alt="创建项目"><img src="http://cdn.mjava.top/blog/KzovQSimage-20210616142925750.png" alt="image-20210616142925750"></p></li><li><p>到凭据页面先点击左侧的<strong>凭据</strong>选项，然后再点击<strong>管理服务账号</strong></p><p><img src="http://cdn.mjava.top/blog/F35uRNimage-20210616143342042.png" alt="image-20210616143342042"></p></li><li><p>然后再点击<strong>创建服务账号</strong></p><p><img src="http://cdn.mjava.top/blog/goyecpimage-20210616143528560.png" alt="image-20210616143528560"></p></li><li><p>然后再填写相关信息，最后点击<strong>完成</strong>（第三步可不填）</p></li></ol><p><img src="http://cdn.mjava.top/blog/EeJqnvimage-20210616143701698.png" alt="image-20210616143701698"><img src="http://cdn.mjava.top/blog/mMp3OVimage-20210616143725389.png" alt="image-20210616143725389"></p><ol start="5"><li><p>点击图中的电子邮件，然后开始创建密钥，选择<strong>JSON格式</strong>，此时就会下载密钥文件到你电脑了</p><p><img src="http://cdn.mjava.top/blog/ASMAbdimage-20210616144108365.png" alt="image-20210616144108365"><img src="http://cdn.mjava.top/blog/l3t61kimage-20210616144343157.png" alt="image-20210616144343157"><img src="http://cdn.mjava.top/blog/eK1hMRimage-20210616144253763.png" alt="image-20210616144253763"></p></li><li><p>打开<a href="https://search.google.com/search-console" rel="noopener" target="_blank"> Google Search Console</a>，依次点击<code>设置-&gt;用户和权限-&gt;拥有者账户右边三个点-&gt;管理资源所有者-&gt;添加所有者-&gt;填入上面密钥中的client_email 的值</code></p></li><li><p>现在可以用<a href="https://cloud.google.com/docs/authentication/production?hl=zh-cn" rel="noopener" target="_blank">作为服务帐号进行身份验证</a>的步骤来使用密钥了</p></li></ol><h2 id="Bing-索引-API-开通步骤"><a href="#Bing-索引-API-开通步骤" class="headerlink" title="Bing 索引 API 开通步骤"></a>Bing 索引 API 开通步骤</h2><ol><li><p>点击<a href="https://www.bing.com/webmasters" rel="noopener" target="_blank">导航栏</a>的齿轮图标</p><p><img src="http://cdn.mjava.top/blog/r3Mn1yimage-20210616144928483.png" alt="image-20210616144928483"></p></li><li><p>点击 <strong>API 访问</strong>，然后点击 <strong>API 密钥</strong>，就可以得到 API 密钥了</p><p><img src="http://cdn.mjava.top/blog/uiRKLqimage-20210616145133559.png" alt="image-20210616145133559"><img src="http://cdn.mjava.top/blog/vl2lysimage-20210616145042851.png" alt="image-20210616145042851"><img src="http://cdn.mjava.top/blog/WnalIwimage-20210616145241124.png" alt="image-20210616145241124"></p></li><li><p>然后就可以按照<a href="https://www.bing.com/webmasters/url-submission-api#APIs" rel="noopener" target="_blank">必应文档</a>来进行API的调用了</p></li></ol><h2 id="Baidu-索引-API-开通步骤"><a href="#Baidu-索引-API-开通步骤" class="headerlink" title="Baidu 索引 API 开通步骤"></a>Baidu 索引 API 开通步骤</h2><p>百度就比较简单粗暴了，直接点击<a href="https://ziyuan.baidu.com/linksubmit/index" rel="noopener" target="_blank">这个链接</a>就可以直接得到 <strong>Token</strong> 了，这个页面下也有对应的 API 调用方法示例，这边就不再重复叙述了</p><p><img src="http://cdn.mjava.top/blog/9qq6TWimage-20210616145825782.png" alt="image-20210616145825782"></p>]]></content>
    
    <summary type="html">
    
      百度、谷歌、必应三大站长API密钥申请流程
    
    </summary>
    
    
      <category term="Tool" scheme="http://blog.mjava.top/categories/Tool/"/>
    
    
      <category term="SEO" scheme="http://blog.mjava.top/tags/SEO/"/>
    
  </entry>
  
  <entry>
    <title>后端服务器时间不一致问题解决手册</title>
    <link href="http://blog.mjava.top/linux/9AFC3EFAEC15479BB5FBC6F670594A94/"/>
    <id>http://blog.mjava.top/linux/9AFC3EFAEC15479BB5FBC6F670594A94/</id>
    <published>2021-06-15T10:32:50.000Z</published>
    <updated>2021-07-22T03:30:13.223Z</updated>
    
    <content type="html"><![CDATA[<h2 id="时区问题"><a href="#时区问题" class="headerlink" title="时区问题"></a>时区问题</h2><p>一般快 8 小时，慢 8 小时的问题都是时区问题，直接把时区改成 CST 时区</p><p>编辑系统环境变量文件 <code>/etc/profile</code></p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">export TZ='CST-8'</span><br></pre></td></tr></table></figure><h2 id="Linux-系统时间不同步问题"><a href="#Linux-系统时间不同步问题" class="headerlink" title="Linux 系统时间不同步问题"></a>Linux 系统时间不同步问题</h2><p>Linux 系统时间比正常时间快几分中或慢几分钟，但是时区是正确的 CST 时区，这是就要用到 <code>ntpdate</code> 这个命令了</p><ol><li>安装</li></ol><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">centos,redhat系列</span></span><br><span class="line">yum install ntpdate</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">debian,ubuntu系列</span></span><br><span class="line">apt install ntpdate</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">archlinux系列</span></span><br><span class="line">pacman -S ntpdate</span><br></pre></td></tr></table></figure><p>2、通过ntpdate命令从时钟服务器同步</p><p>我们这里选用中国ntp服务器<code>cn.pool.ntp.org</code>来作为时钟同步的来源。为能正常访问到<code>cn.pool.ntp.org</code>，你的Linux系统应该能访问外网才行。</p><p>执行命令如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ntpdate cn.pool.ntp.org</span><br></pre></td></tr></table></figure><p>3、配置crontab自动执行同步</p><p>如果每次手动执行，显然是很麻烦的。这里，我们使用<a href="https://linux265.com/news/3851.html" rel="noopener" target="_blank">crontab</a>定时任务来定期执行ntpdate同步命令，例如我们每10分钟或一小时执行一次，可以通过以下方式实现。</p><p>首先在命令终端中输入crontab -e命令，然后输入如下命令保存即可。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">crontab -e</span><br></pre></td></tr></table></figure><p>开始编辑文件内容，输入定时执行命令：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#每10分钟执行一次</span><br><span class="line">*/10 * * * * /usr/sbin/ntpdate cn.pool.ntp.org</span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#每一个小时执行一次</span><br><span class="line">0 * * * * /usr/sbin/ntpdate cn.pool.ntp.org</span><br></pre></td></tr></table></figure><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://linux265.com/news/6009.html" rel="noopener" target="_blank">https://linux265.com/news/6009.html</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;时区问题&quot;&gt;&lt;a href=&quot;#时区问题&quot; class=&quot;headerlink&quot; title=&quot;时区问题&quot;&gt;&lt;/a&gt;时区问题&lt;/h2&gt;&lt;p&gt;一般快 8 小时，慢 8 小时的问题都是时区问题，直接把时区改成 CST 时区&lt;/p&gt;
&lt;p&gt;编辑系统环境变量文件 &lt;cod
      
    
    </summary>
    
    
      <category term="Linux" scheme="http://blog.mjava.top/categories/Linux/"/>
    
    
      <category term="Linux" scheme="http://blog.mjava.top/tags/Linux/"/>
    
      <category term="Time" scheme="http://blog.mjava.top/tags/Time/"/>
    
  </entry>
  
  <entry>
    <title>用Darabonba一键生成7种语言的代码</title>
    <link href="http://blog.mjava.top/tool/0D992236EC6B4E5EAD15886D992FF84B/"/>
    <id>http://blog.mjava.top/tool/0D992236EC6B4E5EAD15886D992FF84B/</id>
    <published>2021-06-05T18:08:19.000Z</published>
    <updated>2021-07-22T03:30:13.223Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://cdn.mjava.top/blog/1PH6HFimage-20210605175031562.png" alt="图片"></p><h2 id="0x1-介绍"><a href="#0x1-介绍" class="headerlink" title="0x1 介绍"></a>0x1 介绍</h2><p>最近在看阿里的SDK的时候，突然看到了一个好玩的东西，这玩意叫 Darabonba。是一种 OpenAPI 应用的领域特定语言。可以利用它为任意风格的接口生成多语言的 SDK、代码示例、测试用例、接口编排等。现在阿里云的多语言 SDK 就是用这个生成的。下面是官方的介绍流程图。</p><p><img src="http://cdn.mjava.top/blog/kS9v8bimage-20210604161124444.png" alt="image-20210604161124444"></p><h2 id="0x2-安装"><a href="#0x2-安装" class="headerlink" title="0x2 安装"></a>0x2 安装</h2><p>我们按照官方的步骤来安装它，因为是用 Nodejs 写的，所以可以用 npm 来安装它</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo npm install -g @darabonba/cli</span><br></pre></td></tr></table></figure><p>安装完成后可以在终端输入 <code>dara</code> ，如果输出版本号就是说明安装成功了</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">➜ dara</span><br><span class="line"></span><br><span class="line">The CLI for Darabonba 1.1.8</span><br></pre></td></tr></table></figure><h2 id="0x3-使用"><a href="#0x3-使用" class="headerlink" title="0x3 使用"></a>0x3 使用</h2><p>安装完成后就可以使用了，首先创建一个文件夹来存放这个项目</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mkdir demo &amp;&amp; cd demo</span><br></pre></td></tr></table></figure><p>然后用 <code>dara</code> 命令来进行初始化模块，然后依次输入包名等信息。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">➜ dara init</span><br><span class="line">package scope: demo</span><br><span class="line">package name: demo</span><br><span class="line">package version: 1.0.0</span><br><span class="line">main entry: ./demo.dara</span><br></pre></td></tr></table></figure><p>初始化完成后，我们就可以在 <code>demo.dara</code> 文件里进行 Darabonba DSL 表达式的编写里</p><p>比如我们编写一个经典的输出 hello world！</p><h3 id="编写-Darabonba-DSL-表达式"><a href="#编写-Darabonba-DSL-表达式" class="headerlink" title="编写 Darabonba DSL 表达式"></a>编写 Darabonba DSL 表达式</h3><p>在 <code>demo.dara</code> 文件里写入如下代码</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Console;</span><br><span class="line"></span><br><span class="line">init()&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hello</span>(<span class="params"></span>): <span class="title">void</span> </span>&#123;</span><br><span class="line">        Console.log(<span class="string">"hello world!"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="安装自定义模块"><a href="#安装自定义模块" class="headerlink" title="安装自定义模块"></a>安装自定义模块</h3><p>因为上面我们用到了 <code>Console</code> 模块，所以我们在当前文件路径下执行如下命令，进行模块的安装</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">dara install</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 执行后将显示下面这些信息</span></span><br><span class="line">fetching from remote repository</span><br><span class="line"></span><br><span class="line">1 libraries installed. (0 local, 1 remote)</span><br></pre></td></tr></table></figure><p>执行完命令后，当前文件夹下就会出现一个 <strong>libraries</strong> 文件夹</p><h3 id="配置-Darafile"><a href="#配置-Darafile" class="headerlink" title="配置 Darafile"></a>配置 Darafile</h3><p><code>Darafile</code> 是 <code>Darabonba</code> 的模块管理文件，类似 <code>Java</code> 中的 <code>pom.xml</code> 或者 <code>Node.js</code> 中的 <code>package.json</code>，这里我们要生成 <code>Go</code> 和 <code>Java</code> 的代码，所以只要做如下配置就可以了。具体的可以查看<a href="https://github.com/aliyun/darabonba/blob/master/doc/darafile.md" rel="noopener" target="_blank">官方的详细介绍</a>。</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"scope"</span>: <span class="string">"demo"</span>,</span><br><span class="line">  <span class="attr">"name"</span>: <span class="string">"demo"</span>,</span><br><span class="line">  <span class="attr">"version"</span>: <span class="string">"1.0.0"</span>,</span><br><span class="line">  <span class="attr">"main"</span>: <span class="string">"./demo.dara"</span>,</span><br><span class="line">  <span class="attr">"libraries"</span>: &#123;</span><br><span class="line">      <span class="attr">"Console"</span>: <span class="string">"darabonba:Console:*"</span></span><br><span class="line">    &#125;,</span><br><span class="line">  <span class="attr">"java"</span>: &#123;</span><br><span class="line">      <span class="attr">"package"</span>: <span class="string">"top.mjava.demo"</span>,</span><br><span class="line">      <span class="attr">"className"</span>:<span class="string">"TestDemo"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 <code>libraries</code> 里配置我们刚才所使用的 <code>Console</code> 依赖模块，在 <code>java</code> 对象字段里配置了包名和类文件名。</p><h3 id="生成代码"><a href="#生成代码" class="headerlink" title="生成代码"></a>生成代码</h3><p>官方暂时只支持 TypeScript、C#、Java、 Go、PHP、Python3、Python2、CPP 的代码生成，后续的话还会支持 Swift、Dart、Ruby、Lua、Kotlin。</p><p>我们这边只生成一下 Java 和 Go 代码，所以执行下面的命令就可以了</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 生成 Java 代码</span></span><br><span class="line">dara codegen java ./java-demo</span><br><span class="line"><span class="meta">#</span><span class="bash"> 生成 Go 代码</span></span><br><span class="line">dara codegen go ./go-demo</span><br></pre></td></tr></table></figure><p>执行完命令后，当前文件夹就会出现 <strong>java-demo</strong> 和 <strong>go-demo</strong> 两个文件夹了。然后就可以进入文件夹看到相应生成的代码了</p><p><strong>Java</strong>：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// This file is auto-generated, don't edit it. Thanks.</span></span><br><span class="line"><span class="keyword">package</span> top.mjava.demo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.aliyun.tea.*;</span><br><span class="line"><span class="keyword">import</span> com.aliyun.teaconsole.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TestDemo</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hello</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        com.aliyun.teaconsole.Client.log(<span class="string">"hello world!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Go</strong>:</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// This file is auto-generated, don't edit it. Thanks.</span></span><br><span class="line"><span class="keyword">package</span> client</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  console  <span class="string">"github.com/alibabacloud-go/tea-console/client"</span></span><br><span class="line">  <span class="string">"github.com/alibabacloud-go/tea/tea"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Client <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewClient</span><span class="params">()</span><span class="params">(*Client, error)</span></span> &#123;</span><br><span class="line">  client := <span class="built_in">new</span>(Client)</span><br><span class="line">  err := client.Init()</span><br><span class="line">  <span class="keyword">return</span> client, err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(client *Client)</span><span class="title">Init</span><span class="params">()</span><span class="params">(_err error)</span></span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="0x3-自定义模块"><a href="#0x3-自定义模块" class="headerlink" title="0x3 自定义模块"></a>0x3 自定义模块</h2><p>上面所用到的 <code>Console</code> 就是通过自定义模块打包上传到了 Darabonba 的<a href="https://darabonba.api.aliyun.com/module" rel="noopener" target="_blank">模块仓库</a>，然后我们可以直接通过 <code>libraries</code> 来使用它。</p><p>所以我们可以自定义自己的模块上传到 Darabonba 模块仓库，接下来我们自定义一个获取 <strong>UUID</strong> 的模块，让它支持 Java 和 Go 语言来生成使用。</p><p><img src="http://cdn.mjava.top/blog/drcDzN%E6%9C%AA%E5%91%BD%E5%90%8D%E6%96%87%E4%BB%B6.jpg" alt="未命名文件"></p><p>从上面的流程图可以知道，模块是由各个语言自己编写代码，然后通过 Darabonba 聚合后上传到模块仓库，然后使用者从仓库安装模块，并且下载对应语言的依赖包。</p><p>我们这边要编写 Java 和 Go 语言获取 UUID 的代码，然后通过 Darabonba 打包上传到模块仓库。</p><h3 id="配置模版"><a href="#配置模版" class="headerlink" title="配置模版"></a>配置模版</h3><p>编写模块我们也是用 Darabonba 先生成各个语言的模版代码，然后再编写相应的具体实现。</p><p>初始化</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">➜ dara init</span><br><span class="line">package scope: greycode</span><br><span class="line">package name: UUID</span><br><span class="line">package version: 1.0.0</span><br><span class="line">main entry: ./main.dara</span><br></pre></td></tr></table></figure><p>我们先配置好 <strong>Darafile</strong>:</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"scope"</span>: <span class="string">"greycode"</span>,</span><br><span class="line">  <span class="attr">"name"</span>: <span class="string">"UUID"</span>,</span><br><span class="line">  <span class="attr">"version"</span>: <span class="string">"1.0.0"</span>,</span><br><span class="line">  <span class="attr">"main"</span>: <span class="string">"./main.dara"</span>,</span><br><span class="line">  <span class="attr">"java"</span>: &#123;</span><br><span class="line"><span class="attr">"package"</span>: <span class="string">"top.mjava.uuid"</span>,</span><br><span class="line"><span class="attr">"packageInfo"</span>: &#123;</span><br><span class="line"><span class="attr">"description"</span>: <span class="string">"UUID generated for Darabonba moudle"</span>,</span><br><span class="line"><span class="attr">"url"</span>: <span class="string">"https://github.com/greycodee/tea-uuid"</span>,</span><br><span class="line"><span class="attr">"developerId"</span>: <span class="string">"greycode"</span>,</span><br><span class="line"><span class="attr">"developerName"</span>: <span class="string">"greycode"</span>,</span><br><span class="line"><span class="attr">"developerEmail"</span>: <span class="string">"zhengminghui99@gmail.com"</span></span><br><span class="line">&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后在 <strong>main.dara</strong> 里编写一个静态方法：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* @return uuid</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">static</span> <span class="function"><span class="keyword">function</span> <span class="title">uuid</span>(<span class="params"></span>): <span class="title">string</span>;</span></span><br></pre></td></tr></table></figure><h3 id="编写-Java-模块"><a href="#编写-Java-模块" class="headerlink" title="编写 Java 模块"></a>编写 Java 模块</h3><p>按上面的步骤配置好后就可以生成 Java 代码了，在当前目录下执行下面的命令</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">dara codegen java ./java</span><br></pre></td></tr></table></figure><p>然后进入 <strong>java 文件夹</strong>，找到 <strong>Client.java</strong>，在 <code>uuid()</code> 方法里添加 UUID 生成的代码</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// This file is auto-generated, don't edit it. Thanks.</span></span><br><span class="line"><span class="keyword">package</span> top.mjava.uuid;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.aliyun.tea.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">uuid</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">      <span class="comment">// 添加这行代码</span></span><br><span class="line">        <span class="keyword">return</span> UUID.randomUUID().toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>编写好代码后，还需要配置 pom.xml 文件，然后把 Java 代码打包发布到 maven 仓库上。</strong></p><p>配置好 pom.xml 文件到下面这几个配置</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>top.mjava<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>tea-uuid<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">packaging</span>&gt;</span>jar<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">name</span>&gt;</span>tea-uuid<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br></pre></td></tr></table></figure><p>还有把 pom.xml 里的仓库配置换成我们自己的，我这边也是用阿里云的 maven 参考。你们可以自己去阿里云 maven 注册自己的账号。</p><figure class="highlight diff"><table><tr><td class="code"><pre><span class="line"><span class="deletion">-  &lt;distributionManagement&gt;</span></span><br><span class="line"><span class="deletion">-    &lt;snapshotRepository&gt;</span></span><br><span class="line"><span class="deletion">-      &lt;id&gt;sonatype-nexus-snapshots&lt;/id&gt;</span></span><br><span class="line"><span class="deletion">-      &lt;url&gt;https://oss.sonatype.org/content/repositories/snapshots&lt;/url&gt;</span></span><br><span class="line"><span class="deletion">-    &lt;/snapshotRepository&gt;</span></span><br><span class="line"><span class="deletion">-    &lt;repository&gt;</span></span><br><span class="line"><span class="deletion">-      &lt;id&gt;sonatype-nexus-staging&lt;/id&gt;</span></span><br><span class="line"><span class="deletion">-      &lt;url&gt;https://oss.sonatype.org/service/local/staging/deploy/maven2/&lt;/url&gt;</span></span><br><span class="line"><span class="deletion">-    &lt;/repository&gt;</span></span><br><span class="line"><span class="deletion">-  &lt;/distributionManagement&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="addition">+ &lt;distributionManagement&gt;</span></span><br><span class="line"><span class="addition">+    &lt;repository&gt;</span></span><br><span class="line"><span class="addition">+        &lt;id&gt;rdc-releases_my&lt;/id&gt;</span></span><br><span class="line"><span class="addition">+        &lt;url&gt;https://repo.rdc.aliyun.com/repository/102997-release-dTwmzu/&lt;/url&gt;</span></span><br><span class="line"><span class="addition">+    &lt;/repository&gt;</span></span><br><span class="line"><span class="addition">+    &lt;snapshotRepository&gt;</span></span><br><span class="line"><span class="addition">+        &lt;id&gt;rdc-snapshots_my&lt;/id&gt;</span></span><br><span class="line"><span class="addition">+        &lt;url&gt;https://repo.rdc.aliyun.com/repository/102997-snapshot-d0gx8B/&lt;/url&gt;</span></span><br><span class="line"><span class="addition">+    &lt;/snapshotRepository&gt;</span></span><br><span class="line"><span class="addition">+ &lt;/distributionManagement&gt;</span></span><br></pre></td></tr></table></figure><p>配置好后就可以执行下面的命令将代码打包推送到远程 maven 仓库了</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mvn clean source:jar javadoc:jar package deploy -Dmaven.test.skip=true -Dgpg.skip</span><br></pre></td></tr></table></figure><p>看到下面的信息就说明部署成功了</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[INFO] 阿里云Maven中央仓库为阿里云云效提供的公共代理仓库，云效也提供了免费、可靠的Maven私有仓库Packages，欢迎您体验使用。https://www.aliyun.com/product/yunxiao/packages?channel=pd_maven_download</span><br><span class="line">[INFO] ------------------------------------------------------------------------</span><br><span class="line">[INFO] BUILD SUCCESS</span><br><span class="line">[INFO] ------------------------------------------------------------------------</span><br><span class="line">[INFO] Total time:  5.538 s</span><br><span class="line">[INFO] Finished at: 2021-06-05T16:00:28+08:00</span><br><span class="line">[INFO] ------------------------------------------------------------------------</span><br></pre></td></tr></table></figure><h4 id="Maven-命令执行出现问题解决办法"><a href="#Maven-命令执行出现问题解决办法" class="headerlink" title="Maven 命令执行出现问题解决办法"></a>Maven 命令执行出现问题解决办法</h4><ul><li><p>如果执行 maven 命令进行部署时，出现下面的错误</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[ERROR] Failed to execute goal org.apache.maven.plugins:maven-gpg-plugin:1.6:sign (sign-artifacts) on project tea-uuid: Unable to execute gpg command: Error while executing process. Cannot run program "gpg": error=2, No such file or directory -&gt; [Help 1]</span><br></pre></td></tr></table></figure><p>可以通过添加 <code>-Dgpg.skip</code> 解决</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mvn clean source:jar javadoc:jar package deploy -Dmaven.test.skip=true -Dgpg.skip</span><br></pre></td></tr></table></figure></li><li><p>如果出现下面的的错误</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[ERROR] Failed to execute goal org.sonatype.plugins:nexus-staging-maven-plugin:1.6.3:deploy (injected-nexus-deploy) on project tea-uuid: Execution injected-nexus-deploy of goal org.sonatype.plugins:nexus-staging-maven-plugin:1.6.3:deploy failed: Server credentials with ID "sonatype-nexus-staging" not found! -</span><br></pre></td></tr></table></figure><p>可以删除 pom.xml 文件里的 <code>sonatype-nexus-staging</code> 配置</p><figure class="highlight diff"><table><tr><td class="code"><pre><span class="line"><span class="deletion">- &lt;plugin&gt;</span></span><br><span class="line"><span class="deletion">-   &lt;groupId&gt;org.sonatype.plugins&lt;/groupId&gt;</span></span><br><span class="line"><span class="deletion">-   &lt;artifactId&gt;nexus-staging-maven-plugin&lt;/artifactId&gt;</span></span><br><span class="line"><span class="deletion">-   &lt;version&gt;1.6.3&lt;/version&gt;</span></span><br><span class="line"><span class="deletion">-   &lt;extensions&gt;true&lt;/extensions&gt;</span></span><br><span class="line"><span class="deletion">-   &lt;configuration&gt;</span></span><br><span class="line"><span class="deletion">-     &lt;serverId&gt;sonatype-nexus-staging&lt;/serverId&gt;</span></span><br><span class="line"><span class="deletion">-     &lt;nexusUrl&gt;https://oss.sonatype.org/&lt;/nexusUrl&gt;</span></span><br><span class="line"><span class="deletion">-     &lt;autoReleaseAfterClose&gt;true&lt;/autoReleaseAfterClose&gt;</span></span><br><span class="line"><span class="deletion">-   &lt;/configuration&gt;</span></span><br><span class="line"><span class="deletion">- &lt;/plugin&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="编写-Go-模块"><a href="#编写-Go-模块" class="headerlink" title="编写 Go 模块"></a>编写 Go 模块</h3><p>老规矩，首先先生成 Go 的代码</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">dara codegen go ./go</span><br></pre></td></tr></table></figure><p>然后编辑 <code>client.go</code> 文件，改为如下代码</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// This file is auto-generated, don't edit it. Thanks.</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* @return uuid</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">package</span> client</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">"github.com/google/uuid"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Uuid</span> <span class="params">()</span> <span class="params">(_result <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">  <span class="comment">// V4 基于随机数</span></span><br><span class="line">  u4 := uuid.New()</span><br><span class="line">  <span class="keyword">return</span> u4.String()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后 <code>go.mod</code> 文件里的 module 改为我们的上传 Go 代码的仓库地址</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">module github.com/greycodee/tea-uuid-<span class="keyword">go</span></span><br></pre></td></tr></table></figure><p>然后推送到 GitHub 并打上一个 Tag 作为这个 Go 库的版本号，这边我设置版本号为 <code>v1.0.0</code></p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git tag v1.0.0</span><br><span class="line">git push origin v1.0.0</span><br></pre></td></tr></table></figure><h3 id="上传-Darabonba-仓库"><a href="#上传-Darabonba-仓库" class="headerlink" title="上传 Darabonba 仓库"></a>上传 Darabonba 仓库</h3><p>编写好相应模块的代码并打包上传到对应的原创仓库后，就可以配置 <strong>Darafile</strong> 文件了</p><p>在 Darafile 添加 releases 信息</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"scope"</span>: <span class="string">"greycode"</span>,</span><br><span class="line">  <span class="attr">"name"</span>: <span class="string">"UUID"</span>,</span><br><span class="line">  <span class="attr">"version"</span>: <span class="string">"1.0.0"</span>,</span><br><span class="line">  <span class="attr">"main"</span>: <span class="string">"./main.dara"</span>,</span><br><span class="line">  <span class="attr">"releases"</span>: &#123;</span><br><span class="line"><span class="attr">"go"</span>: <span class="string">"github.com/greycodee/tea-uuid-go/client:v1.0.0"</span>,</span><br><span class="line"><span class="attr">"java"</span>: <span class="string">"top.mjava:tea-uuid:1.0"</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"java"</span>: &#123;</span><br><span class="line"><span class="attr">"package"</span>: <span class="string">"top.mjava.uuid"</span>,</span><br><span class="line"><span class="attr">"packageInfo"</span>: &#123;</span><br><span class="line"><span class="attr">"description"</span>: <span class="string">"UUID generated for Darabonba moudle"</span>,</span><br><span class="line"><span class="attr">"url"</span>: <span class="string">"https://github.com/greycodee/tea-uuid"</span>,</span><br><span class="line"><span class="attr">"developerId"</span>: <span class="string">"greycode"</span>,</span><br><span class="line"><span class="attr">"developerName"</span>: <span class="string">"greycode"</span>,</span><br><span class="line"><span class="attr">"developerEmail"</span>: <span class="string">"zhengminghui99@gmail.com"</span></span><br><span class="line">&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后去 <a href="https://darabonba.api.aliyun.com/admin/maintainer" rel="noopener" target="_blank">Darabonba 模块仓库</a>里注册一个账号，然后点击<code>个人中心-&gt;Scope-&gt;添加scope</code>，添加一个 scope ，<strong>保持和 Darafile 文件里的 scope 一致。</strong></p><p>注册完成后在项目目录下执行 <code>dara login</code> 命令，输入刚才注册的账号密码，进行登陆。</p><p>执行 <code>dara pack</code> 进行打包</p><p>再执行 <code>dara publish</code> 进行发布</p><p>发布完成后就可在  Darabonba 模块仓库里看到刚才发布的包了</p><p><img src="http://cdn.mjava.top/blog/Cxudyeimage-20210605170948596.png" alt="image-20210605170948596"></p><blockquote><p>Darabonba UUID 模块代码地址：<a href="https://github.com/greycodee/tea-uuid" rel="noopener" target="_blank">https://github.com/greycodee/tea-uuid</a></p><p>Go 模块代码地址： <a href="https://github.com/greycodee/tea-uuid-go" rel="noopener" target="_blank">https://github.com/greycodee/tea-uuid-go</a></p></blockquote><h3 id="使用自定义的模块"><a href="#使用自定义的模块" class="headerlink" title="使用自定义的模块"></a>使用自定义的模块</h3><p>上传 Darabonba 模块仓库后，我们就可以向刚开始使用 Console 模块那样来使用 UUID 模块了</p><p>Darafile 添加 libraries</p><figure class="highlight"><table><tr><td class="code"><pre><span class="line">"libraries": &#123;</span><br><span class="line">  "UUID": "greycode:UUID:*",</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 <code>dara</code> 代码里使用：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Console;</span><br><span class="line"><span class="keyword">import</span> UUID;</span><br><span class="line">init()&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hello</span>(<span class="params"></span>): <span class="title">void</span> </span>&#123;</span><br><span class="line">Console.log(UUID.uuid());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;http://cdn.mjava.top/blog/1PH6HFimage-20210605175031562.png&quot; alt=&quot;图片&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;0x1-介绍&quot;&gt;&lt;a href=&quot;#0x1-介绍&quot; class=&quot;headerlink&quot;
      
    
    </summary>
    
    
      <category term="Tool" scheme="http://blog.mjava.top/categories/Tool/"/>
    
    
      <category term="Darabonba" scheme="http://blog.mjava.top/tags/Darabonba/"/>
    
  </entry>
  
  <entry>
    <title>什么是HTTP协议？</title>
    <link href="http://blog.mjava.top/protocol/0143CD7666CD44389FE6F565E10EEE1A/"/>
    <id>http://blog.mjava.top/protocol/0143CD7666CD44389FE6F565E10EEE1A/</id>
    <published>2021-06-04T11:44:00.000Z</published>
    <updated>2021-07-22T03:30:13.223Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://cdn.mjava.top/blog/jdFFPmbCNQCyhttp%E5%8D%8F%E8%AE%AE.png" alt="http协议"></p><h2 id="版本介绍"><a href="#版本介绍" class="headerlink" title="版本介绍"></a>版本介绍</h2><p>HTTP 协议不用我多说了吧，大家都知道，现在我 web 开发一般都是使用 HTTP 协议来进行通信的。到目前为止，HTTP 进行了几次版本更新，HTTP 1.1 就是表示HTTP 的 1.1 版本。1.1 版本也是目前大部分网站所用的版本。</p><h3 id="HTTP-0-9"><a href="#HTTP-0-9" class="headerlink" title="HTTP 0.9"></a>HTTP 0.9</h3><ul><li>发布时间：1991 年</li><li>简介：梦开始的地方，只接受GET一种请求方法，没有在通讯中指定版本号，且不支持请求头。由于该版本不支持POST方法，因此客户端无法向服务器传递太多信息。</li></ul><h3 id="HTTP-1-0"><a href="#HTTP-1-0" class="headerlink" title="HTTP 1.0"></a>HTTP 1.0</h3><ul><li>发布时间：1996 年 5 月</li><li>简介：这是第一个在通讯中指定版本号的HTTP协议版本。同时比 0.9 版本增加大量新特性。非持续连接，每次都要重新与服务器建立连接。</li></ul><h3 id="HTTP-1-1"><a href="#HTTP-1-1" class="headerlink" title="HTTP 1.1"></a>HTTP 1.1</h3><ul><li>发布时间：1997 年1月</li><li>简介：默认采用持续连接（Connection: keep-alive），能很好地配合代理服务器工作。还支持以<a href="https://zh.wikipedia.org/wiki/HTTP管线化" rel="noopener" target="_blank">管道方式</a>在同时发送多个请求，以便降低线路负载，提高传输速度。同时这也是目前最流行的版本。</li></ul><p>HTTP/1.1相较于HTTP/1.0协议的区别主要体现在：</p><ul><li>缓存处理</li><li>带宽优化及网络连接的使用</li><li>错误通知的管理</li><li>消息在网络中的发送</li><li>互联网地址的维护</li><li>安全性及完整性</li></ul><h3 id="HTTP-2-0"><a href="#HTTP-2-0" class="headerlink" title="HTTP 2.0"></a>HTTP 2.0</h3><ul><li>发布时间：2015 年 5 月</li><li>简介：HTTP/2 是 <a href="https://zh.wikipedia.org/wiki/HTTP" rel="noopener" target="_blank">HTTP</a> 协议自 1999 年 HTTP 1.1 的改进版 RFC 2616 发布后的首个更新，主要基于 <a href="https://zh.wikipedia.org/wiki/SPDY" rel="noopener" target="_blank">SPDY</a> 协议。它由<a href="https://zh.wikipedia.org/wiki/互联网工程任务组" rel="noopener" target="_blank">互联网工程任务组</a>（IETF）的Hypertext Transfer Protocol Bis（httpbis）工作小组进行开发。该组织于 2014 年 12 月将 HTTP/2 标准提议递交至 <a href="https://zh.wikipedia.org/w/index.php?title=IESG&action=edit&redlink=1" rel="noopener" target="_blank">IESG</a> 进行讨论，于 2015 年 2 月 17 日被批准。</li></ul><h2 id="报文格式"><a href="#报文格式" class="headerlink" title="报文格式"></a>报文格式</h2><h3 id="请求报文"><a href="#请求报文" class="headerlink" title="请求报文"></a>请求报文</h3><p>请求报文分为 4 个部分，分别是请求行、请求头、换行行、请求数据，每个部分的末尾都会带上回车符（CR，ASCII：0d）和换行符（LF，ASCII：0a）</p><p>其中请求行分为请求方法、请求的 URL 地址、HTTP 版本号，每个字段用<strong>空格</strong>（ASCII：20）来分隔</p><p>请求头部分可以有多行，每行用回车符和换行符区分</p><p><img src="http://cdn.mjava.top/blog/moI2oju8Cl9pHTTP1.1_%E8%AF%B7%E6%B1%82%E6%8A%A5%E6%96%87.jpg" alt="HTTP1.1_请求报文"></p><p>为了方便理解，我们可以用 Wireshark 来抓取一个 HTTP 请求来看看，并把它和上图进行关联</p><p><img src="http://cdn.mjava.top/blog/H3flLsi1tGaAHTTP%E6%8A%A5%E6%96%87%E6%A0%BC%E5%BC%8F.png" alt="HTTP报文格式"></p><h3 id="响应报文"><a href="#响应报文" class="headerlink" title="响应报文"></a>响应报文</h3><p>响应报文和请求报文基本差不多，唯一有区别就第一行状态行和请求报文的第一行请求行有区别。</p><p>状态行也分为三个部分，分别是 HTTP 版本、状态码、状态码描述，每个部分用空格进行分隔。</p><p>响应头和请求头一样，可以有多行</p><p><img src="http://cdn.mjava.top/blog/TIHv2ArvWDqDHTTP%E5%93%8D%E5%BA%94%E6%8A%A5%E6%96%87%20(1).jpg" alt="HTTP响应报文 (1)"></p><p>同样，用 Wireshark 抓取一个响应报文，来和上图进行一一对应。</p><p><img src="http://cdn.mjava.top/blog/QP0vZ8wcnVZnHTTP%E5%93%8D%E5%BA%94%E6%8A%A5%E6%96%87%20(2).png" alt="HTTP响应报文 (2)"></p><h2 id="持续连接和非持续连接"><a href="#持续连接和非持续连接" class="headerlink" title="持续连接和非持续连接"></a>持续连接和非持续连接</h2><p>上面说了，HTTP 1.1 的连接由原来的非持续连接变为了持续连接（Connection: keep-alive）。那么这两个有什么区别呢？</p><p><strong>非持续连接</strong>指的是当向服务器多次请求资源时，每次都需要单独的进行 TCP 的连接和断开。</p><p><strong>持续连接</strong>指的是当向服务器请求资源时，可以共用一个 TCP 连接来进行资源的传输。</p><blockquote><p>尽管 HTTP 1.1 默认使用持续连接，但是也可以配置为非持续连接，设置方法：Connection 字段设置为 close</p></blockquote><p>为了好理解，为画了一张图，图中省略了 TCP 建立连接和断开连接的细致步骤。</p><p><img src="http://cdn.mjava.top/blog/BmuEgd8fnYPUHTTP%E6%8C%81%E7%BB%AD%E8%BF%9E%E6%8E%A5%E5%92%8C%E9%9D%9E%E6%8C%81%E7%BB%AD%E8%BF%9E%E6%8E%A5.jpg" alt="HTTP持续连接和非持续连接"></p><h2 id="请求方法"><a href="#请求方法" class="headerlink" title="请求方法"></a>请求方法</h2><blockquote><p>一般我们常用的只有 GET 和 POST 两个请求方法，但是如果遵循 REST 风格来进行 API 接口的设计，就可以用到下面的一些请求方法了。</p></blockquote><ul><li>OPTIONS：这个方法会请求服务器返回该资源所支持的所有HTTP<strong>请求方法</strong>。</li><li>GET：获取指定资源地址的数据，不推荐进行上传数据等操作。</li><li>HEAD：服务器在响应 HEAD 请求时不会回传 Body 资源的内容部分，这样，我们可以不传输全部内容的情况下，就可以获取服务器的响应头信息。</li><li>POST：POST 请求会 向指定资源提交数据，请求服务器进行处理，请求数据会被包含在请求体中。</li><li>PUT：可以将指定资源的最新数据传送给服务器取代指定的资源的内容。</li><li>DELETE：删除指定资源的数据。</li><li>TRACE：TRACE 请求服务器回显其收到的请求信息，该方法主要用于 HTTP 请求的测试或诊断。</li><li>……</li></ul><h2 id="响应码"><a href="#响应码" class="headerlink" title="响应码"></a>响应码</h2><h3 id="1xx"><a href="#1xx" class="headerlink" title="1xx"></a>1xx</h3><p>Informational（信息性状态码），表示接收的请求正在处理，具体可以查看 <a href="https://datatracker.ietf.org/doc/html/rfc2616#page-57" rel="noopener" target="_blank">RFC 文档</a></p><h3 id="2xx"><a href="#2xx" class="headerlink" title="2xx"></a>2xx</h3><p>Success（成功状态码），请求正常处理完毕，具体可以查看 <a href="https://datatracker.ietf.org/doc/html/rfc2616#page-58" rel="noopener" target="_blank">RFC 文档</a></p><h3 id="3xx"><a href="#3xx" class="headerlink" title="3xx"></a>3xx</h3><p>Redirection（重定向状态码），需要进行附加操作以完成请求，具体可以查看 <a href="https://datatracker.ietf.org/doc/html/rfc2616#page-61" rel="noopener" target="_blank">RFC 文档</a></p><h3 id="4xx"><a href="#4xx" class="headerlink" title="4xx"></a>4xx</h3><p>Client Error（客户端错误状态码），服务器无法处理请求，具体可以查看 <a href="https://datatracker.ietf.org/doc/html/rfc2616#page-65" rel="noopener" target="_blank">RFC 文档</a></p><h3 id="5xx"><a href="#5xx" class="headerlink" title="5xx"></a>5xx</h3><p>Server Error（服务器错误状态码），服务器处理请求出错，具体可以查看 <a href="https://datatracker.ietf.org/doc/html/rfc2616#page-70" rel="noopener" target="_blank">RFC 文档</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;http://cdn.mjava.top/blog/jdFFPmbCNQCyhttp%E5%8D%8F%E8%AE%AE.png&quot; alt=&quot;http协议&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;版本介绍&quot;&gt;&lt;a href=&quot;#版本介绍&quot; class=&quot;header
      
    
    </summary>
    
    
      <category term="Protocol" scheme="http://blog.mjava.top/categories/Protocol/"/>
    
    
      <category term="HTTP协议" scheme="http://blog.mjava.top/tags/HTTP%E5%8D%8F%E8%AE%AE/"/>
    
  </entry>
  
  <entry>
    <title>使用Nacos实现网关动态路由</title>
    <link href="http://blog.mjava.top/spring/EEF92888390B4E7C866FE7ADA6A0B42B/"/>
    <id>http://blog.mjava.top/spring/EEF92888390B4E7C866FE7ADA6A0B42B/</id>
    <published>2021-05-08T22:47:54.000Z</published>
    <updated>2021-07-22T03:30:13.223Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>网关作为一个主要的外部流量入口，其重启的次数当然是越少越好，所以不能有时候为了修改一个路由就重启整个网关服务，这样的话网关就不是一个高可用的网关。当然，有时候要新增或修改代码层面的自定义的过滤器时还是要重启网关的，所以我们能做的就是尽可能减少不必要的重启。这里就可以引入阿里巴巴开源的 <a href="https://nacos.io/zh-cn/" rel="noopener" target="_blank">Nacos</a> 了。</p><h2 id="什么是-Nacos？"><a href="#什么是-Nacos？" class="headerlink" title="什么是 Nacos？"></a>什么是 Nacos？</h2><p>Naocs 是阿里巴巴开源的一款微服务组件，它提供注册中心和配置中心来供我们使用。并且 Nacos 同时支持 AP 模式和 CP 模式来供我们选择使用。具体可以查看<a href="https://nacos.io/zh-cn/docs/what-is-nacos.html" rel="noopener" target="_blank">官方文档</a>来进一步了解。</p><h2 id="安装-Nacos"><a href="#安装-Nacos" class="headerlink" title="安装 Nacos"></a>安装 Nacos</h2><p>本地的话我这边建议直接用 Docker 来安装Nacos，省心省力。按照官方提供的方法，我们可以直接下载官方提供的 <code>docker-compose</code> 文件来启动 Nacos。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 克隆项目</span></span><br><span class="line">git clone https://github.com/nacos-group/nacos-docker.git</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># 进入项目目录 然后启动</span></span></span><br><span class="line">cd nacos-docker</span><br><span class="line">docker-compose -f example/standalone-mysql-5.7.yaml up</span><br></pre></td></tr></table></figure><p>我这边是启动了一个使用 MySQL 5.7 的单机 Nacos，如果你想使用其他的数据库或者启动集群的话可以参照一下<a href="https://nacos.io/zh-cn/docs/quick-start-docker.html" rel="noopener" target="_blank">官方文档</a></p><p>待启动完成后，就可以用浏览器打开 <code>http://localhost:8848/nacos</code> 进入 Nacos的管理台了。默认的登陆账号密码都是 <code>nacos</code></p><p><img src="http://cdn.mjava.top/blog/NMae2bimage-20210508221303506.png" alt="image-20210508221303506"></p><h2 id="网关使用-Nacos"><a href="#网关使用-Nacos" class="headerlink" title="网关使用 Nacos"></a>网关使用 Nacos</h2><blockquote><p>我这边 Spring Cloud 使用的版本号是 <code>2020.0.2</code> </p></blockquote><h3 id="Nacos-创建配置"><a href="#Nacos-创建配置" class="headerlink" title="Nacos 创建配置"></a>Nacos 创建配置</h3><p>在开始配置网关项目前，我们先在 Nacos 里创建一个配置，等下网关启动的时候就用这个配置。</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line"><span class="attr">  port:</span> <span class="number">8989</span></span><br><span class="line"></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">  cloud:</span></span><br><span class="line"><span class="attr">    gateway:</span></span><br><span class="line"><span class="attr">      routes:</span></span><br><span class="line"><span class="attr">        - id:</span> <span class="string">route-demo</span></span><br><span class="line"><span class="attr">          uri:</span> <span class="attr">https://baidu.com</span></span><br><span class="line"><span class="attr">          predicates:</span></span><br><span class="line"><span class="bullet">            -</span> <span class="string">Path=/**</span></span><br></pre></td></tr></table></figure><p>在上面配置中，我们定义了项目启动端口为 <code>8989</code>，然后创建了一个路由，这个路由接收所有请求，然后转发到百度。</p><p><img src="http://cdn.mjava.top/blog/9NZiPVimage-20210508222500763.png" alt="image-20210508222500763"></p><h3 id="依赖配置"><a href="#依赖配置" class="headerlink" title="依赖配置"></a>依赖配置</h3><p>因为 Nacos 是阿里巴巴开源的，所以这里要用到 <code>spring-cloud-alibaba-dependencies</code> 这个依赖，在 Spring Cloud Gateway 项目里面添加如下依赖：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-config<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-alibaba-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>2021.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h3><p>导入依赖后，我们在 <code>resources</code> 文件夹下创建一个 <code>bootstrap.yml</code> 文件，然后在里面填入 Nacos 配置中心的相关的信息</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">  cloud:</span></span><br><span class="line"><span class="attr">    nacos:</span></span><br><span class="line"><span class="attr">      server-addr:</span> <span class="attr">localhost:8848</span></span><br><span class="line"><span class="attr">      config:</span></span><br><span class="line"><span class="attr">        prefix:</span> <span class="string">gateway</span></span><br><span class="line"><span class="attr">        file-extension:</span> <span class="string">yml</span></span><br></pre></td></tr></table></figure><p>上面配置中，<code>server-addr</code> 配置了本地 Nacos 的地址，<code>prefix</code> 配置了刚才配置文件的前缀，<code>file-extension</code> 配置了刚才 Nacos 上创建的文件扩展名。</p><p>在 Nacos Spring Cloud 中，<code>dataId</code> 的完整格式如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$&#123;prefix&#125;-$&#123;spring.profiles.active&#125;.$&#123;file-extension&#125;</span><br></pre></td></tr></table></figure><ul><li><code>prefix</code> 默认为 <code>spring.application.name</code> 的值，也可以通过配置项 <code>spring.cloud.nacos.config.prefix</code>来配置。</li><li><code>spring.profiles.active</code> 即为当前环境对应的 profile，详情可以参考 <a href="https://docs.spring.io/spring-boot/docs/current/reference/html/boot-features-profiles.html#boot-features-profiles" rel="noopener" target="_blank">Spring Boot文档</a>。 <strong>注意：当 <code>spring.profiles.active</code> 为空时，对应的连接符 <code>-</code> 也将不存在，dataId 的拼接格式变成 <code>${prefix}.${file-extension}</code></strong></li><li><code>file-exetension</code> 为配置内容的数据格式，可以通过配置项 <code>spring.cloud.nacos.config.file-extension</code> 来配置。目前只支持 <code>properties</code> 和 <code>yaml</code> 类型。</li></ul><h3 id="启动网关项目"><a href="#启动网关项目" class="headerlink" title="启动网关项目"></a>启动网关项目</h3><p>配置完成后，如果你和我用的 Spring Cloud 版本一样是 <code>2020.0.2</code> 版的话，你启动项目后会发现，欸？？怎么启动端口还是默认的 <code>8080</code> 呢？</p><p>发生这种情况是因为项目没有读取 <code>bootstrap.yml</code> 文件，这是因为 Spring Cloud 从数字版开始，把 <code>bootstrap</code> 默认为关闭状态，此时如果要使用 <code>bootstrap</code> 的话就要导入以下依赖就可以了</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-bootstrap<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>导入依赖后再次启动网关，发现启动端口变成了我们刚在 Nacos 上配置的 <code>8989</code> 了，这时你打开浏览器访问 <code>http://localhost:8989</code> 就会跳转到百度首页了。</p><h2 id="动态路由"><a href="#动态路由" class="headerlink" title="动态路由"></a>动态路由</h2><p>其实到这一步，动态路由的工作基本上已经完成了，现在你可以在 Nacos 找到刚才配置 <code>gateway.yml</code>，然后点击右边的编辑按钮，修改一下配置的路由。比如我这边把它改成知乎的地址。</p><p><img src="http://cdn.mjava.top/blog/34d52Bimage-20210508224219917.png" alt="image-20210508224219917"></p><p>配置完后点击下面的发布，此时你不用任何操作，不用重启网关项目，直接再次访问 <code>http://localhost:8989</code> ，就会发现现在会跳转到知乎了。这样就实现了动态路由了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;网关作为一个主要的外部流量入口，其重启的次数当然是越少越好，所以不能有时候为了修改一个路由就重启整个网关服务，这样的话网关就不是一个高可用的
      
    
    </summary>
    
    
      <category term="Spring" scheme="http://blog.mjava.top/categories/Spring/"/>
    
    
      <category term="Nacos" scheme="http://blog.mjava.top/tags/Nacos/"/>
    
      <category term="Spring Cloud Gateway" scheme="http://blog.mjava.top/tags/Spring-Cloud-Gateway/"/>
    
  </entry>
  
  <entry>
    <title>Dubbo项目双注册中心</title>
    <link href="http://blog.mjava.top/spring/C2E28AA517AA45768B679D93F248B5DE/"/>
    <id>http://blog.mjava.top/spring/C2E28AA517AA45768B679D93F248B5DE/</id>
    <published>2021-05-07T13:29:00.000Z</published>
    <updated>2021-07-22T03:30:13.223Z</updated>
    
    <content type="html"><![CDATA[<h2 id="🤔为什么要双注册中心？"><a href="#🤔为什么要双注册中心？" class="headerlink" title="🤔为什么要双注册中心？"></a>🤔为什么要双注册中心？</h2><p>当前 Dubbo 版本注册粒度是以接口粒度来注册的，而 SpringBoot 是以服务为粒度来注册的。而且 Dubbo 有自己的注册中心（当然 Spring Cloud Alibaba Dubbo 的注册中心可以挂靠在 Spring 上）。所以当一个项目既要调用 Dubbo 服务，又要提供自己的 Web 接口给网关调用时，就要为该项目设置两个注册中心，一个 Dubbo，一个 SpringBoot的（当然可以注册到同一个注册中心上）。</p><h2 id="🛠️创建一个-Dubbo-服务提供者"><a href="#🛠️创建一个-Dubbo-服务提供者" class="headerlink" title="🛠️创建一个 Dubbo 服务提供者"></a>🛠️创建一个 Dubbo 服务提供者</h2><p>我们先创建一个 Dubbo 服务提供者，然后把它注册到 Zoookeeper 上。我这边用到是 <code>2.7.10</code> 版本到 Dubbo，不同 Dubbo 版本到配置有所差异化。</p><p>pom 依赖：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.dubbo<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>dubbo-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.7.10<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.dubbo<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>dubbo-dependencies-zookeeper<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.7.10<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然后我们定义一个接口，返回一些文字，记得加上 <code>@DubboService</code> 注解，让 Dubbo 应用发现这个接口并注册到注册 Zookeeper 上。同时在启动类上面还要加上 <code>@EnableDubbo</code> 注解。当然你也可以用配置到方式来配置这些。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@DubboService</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoServiceImpl</span> <span class="keyword">implements</span> <span class="title">DemoService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"hello! This is Dubbo's demo"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义好接口后，我们在配置文件加上如下配置：</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line"><span class="attr">  port:</span> <span class="number">8787</span></span><br><span class="line"><span class="attr">dubbo:</span></span><br><span class="line"><span class="attr">  application:</span></span><br><span class="line"><span class="attr">    id:</span> <span class="string">dubbo-privode</span></span><br><span class="line"><span class="attr">  protocol:</span></span><br><span class="line"><span class="attr">    name:</span> <span class="string">dubbo</span></span><br><span class="line"><span class="attr">    port:</span> <span class="number">28808</span></span><br><span class="line"><span class="attr">  registry:</span></span><br><span class="line"><span class="attr">    address:</span> <span class="attr">zookeeper://localhost:2181</span></span><br></pre></td></tr></table></figure><p>在上面配置中，我们定义来项目启动到端口为 <code>8787</code> ，然后配置了 Dubbo 的协议名称和端口，同时也配置了注册地址为本地的 Zookeeper 的地址。</p><p>项目启动后，我们就可以看到 Zookeeper 的节点上多了一个 <code>dubbo</code> 节点，节点下面有我们注册上去的 Dubbo 接口</p><p><img src="http://cdn.mjava.top/blog/UwzF7YUntitled.png" alt="Dubbo%20%E9%A1%B9%E7%9B%AE%E5%8F%8C%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83%20a2369534007b4606b16f9819157f3c3a/Untitled.png"></p><h2 id="🛠️创建一个服务消费者"><a href="#🛠️创建一个服务消费者" class="headerlink" title="🛠️创建一个服务消费者"></a>🛠️创建一个服务消费者</h2><p>消费者基本和服务提供者配置相同，只是要额外加上 web 依赖，应为我们要对外提供 HTTP 接口。</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然后 yml 配置稍作修改，改下端口什么的</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line"><span class="attr">  port:</span> <span class="number">8788</span></span><br><span class="line"><span class="attr">dubbo:</span></span><br><span class="line"><span class="attr">  application:</span></span><br><span class="line"><span class="attr">    id:</span> <span class="string">dubbo-consumer</span></span><br><span class="line"><span class="attr">  protocol:</span></span><br><span class="line"><span class="attr">    name:</span> <span class="string">dubbo</span></span><br><span class="line"><span class="attr">    port:</span> <span class="number">28808</span></span><br><span class="line"><span class="attr">  registry:</span></span><br><span class="line"><span class="attr">    address:</span> <span class="attr">zookeeper://localhost:2181</span></span><br></pre></td></tr></table></figure><p>配置好后，我们创建一个对外的 HTTP 接口，并且调用上面服务提供者提供的服务，我们可以直接用注解 <code>@DubboReference</code> 来表示我们要调用 Dubbo 服务接口。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DubboConsumer</span> </span>&#123;</span><br><span class="line">    <span class="meta">@DubboReference</span></span><br><span class="line">    DemoService demoService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/consumer"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">dubboDemo</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> demoService.hello();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>启动项目后，注册中心就会出现一个 <code>consumers</code> 节点，这个节点下面有我们注册上去是服务消费者。</p><p><img src="http://cdn.mjava.top/blog/XuXwekUntitled%201.png" alt="Dubbo%20%E9%A1%B9%E7%9B%AE%E5%8F%8C%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83%20a2369534007b4606b16f9819157f3c3a/Untitled%201.png"></p><p>这时候我们直接访问 <code>[http://localhost:8788/consumer](http://localhost:8788/consumer)</code> 地址，页面就会响应 <code>hello! This is Dubbo&#39;s demo</code> 字符串，这是我们在服务提供者中定义返回的数据，说明我们成功调用了服务提供者提供的 Dubbo 服务。</p><h2 id="🔑为消费者再配置一个注册中心"><a href="#🔑为消费者再配置一个注册中心" class="headerlink" title="🔑为消费者再配置一个注册中心"></a>🔑为消费者再配置一个注册中心</h2><p>这时候如果我们网关要调用这个消费者提供的 HTTP 接口怎么办？</p><p>你可能会想，可以直接把<code>http://localhost:8788/consumer</code> 这个地址配置到网关路由到 <code>uri</code> 字段上。但是我们一般项目不单单是只有一个，而且有时候地址也会变化，这时候网关就要用到服务名来调用对应到服务，网关一般以 <code>lb://service-name</code> 来调用对应到服务。</p><p>如果网关想要以服务名来调用这个消费者，那么我们就要以服务名到方式来把这个消费者注册到 Zookeeper 上。</p><p>由于 Spring Cloud 官方已经将 Zookeeper 整合进了 Spring Cloud 体系，所以我们可以直接用 Spring Cloud 下的包。需要添加如下依赖：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-zookeeper-discovery<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">version</span>&gt;</span>Hoxton.SR11<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span><br></pre></td></tr></table></figure><p>同时配置文件需要再添加如下配置，下面的配置中我们指定了要注册到 Zookeeper 到服务名 <code>dubbo-consumer</code> ,配置了注册中心到地址。</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">  application:</span></span><br><span class="line"><span class="attr">    name:</span> <span class="string">dubbo-consumer</span></span><br><span class="line"><span class="attr">  cloud:</span></span><br><span class="line"><span class="attr">    zookeeper:</span></span><br><span class="line"><span class="attr">      connect-string:</span> <span class="attr">localhost:2181</span></span><br></pre></td></tr></table></figure><p>同时启动类也要加上 <code>@EnableDiscoveryClient</code> 注解，不然是不会注册到 Zookeeper 上到。</p><p>启动项目后，我们就可以在 Zookeeper 的 <code>services</code> 节点下面看到我们的服务了</p><p><img src="http://cdn.mjava.top/blog/ClmFp6Untitled%202.png" alt="Dubbo%20%E9%A1%B9%E7%9B%AE%E5%8F%8C%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83%20a2369534007b4606b16f9819157f3c3a/Untitled%202.png"></p><p>同样的我们可以看到注册上去到数据：</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"name"</span>: <span class="string">"dubbo-consumer"</span>,</span><br><span class="line">    <span class="attr">"id"</span>: <span class="string">"beff8ece-85a3-47ed-bd0b-34fc193eb3f1"</span>,</span><br><span class="line">    <span class="attr">"address"</span>: <span class="string">"169.254.238.114"</span>,</span><br><span class="line">    <span class="attr">"port"</span>: <span class="number">8788</span>,</span><br><span class="line">    <span class="attr">"sslPort"</span>: <span class="literal">null</span>,</span><br><span class="line">    <span class="attr">"payload"</span>: &#123;</span><br><span class="line">        <span class="attr">"@class"</span>: <span class="string">"org.springframework.cloud.zookeeper.discovery.ZookeeperInstance"</span>,</span><br><span class="line">        <span class="attr">"id"</span>: <span class="string">"application-1"</span>,</span><br><span class="line">        <span class="attr">"name"</span>: <span class="string">"dubbo-consumer"</span>,</span><br><span class="line">        <span class="attr">"metadata"</span>: &#123;</span><br><span class="line">            <span class="attr">"instance_status"</span>: <span class="string">"UP"</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">"registrationTimeUTC"</span>: <span class="number">1620123669588</span>,</span><br><span class="line">    <span class="attr">"serviceType"</span>: <span class="string">"DYNAMIC"</span>,</span><br><span class="line">    <span class="attr">"uriSpec"</span>: &#123;</span><br><span class="line">        <span class="attr">"parts"</span>: [</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="attr">"value"</span>: <span class="string">"scheme"</span>,</span><br><span class="line">                <span class="attr">"variable"</span>: <span class="literal">true</span></span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="attr">"value"</span>: <span class="string">"://"</span>,</span><br><span class="line">                <span class="attr">"variable"</span>: <span class="literal">false</span></span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="attr">"value"</span>: <span class="string">"address"</span>,</span><br><span class="line">                <span class="attr">"variable"</span>: <span class="literal">true</span></span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="attr">"value"</span>: <span class="string">":"</span>,</span><br><span class="line">                <span class="attr">"variable"</span>: <span class="literal">false</span></span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="attr">"value"</span>: <span class="string">"port"</span>,</span><br><span class="line">                <span class="attr">"variable"</span>: <span class="literal">true</span></span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="🍰网关调用"><a href="#🍰网关调用" class="headerlink" title="🍰网关调用"></a>🍰网关调用</h2><p>服务注册上去后，我们就可以修改下我们上节网关项目到路由配置，把它改成用服务名调用。我们可以修改 yml 配置，把 <code>uri</code> 改成服务调用的格式</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">  cloud:</span></span><br><span class="line"><span class="attr">    gateway:</span></span><br><span class="line"><span class="attr">      routes:</span></span><br><span class="line"><span class="attr">        - id:</span> <span class="string">route-demo</span></span><br><span class="line"><span class="attr">          uri:</span> <span class="attr">lb://dubbo-consumer</span></span><br><span class="line"><span class="attr">          predicates:</span></span><br><span class="line"><span class="bullet">            -</span> <span class="string">Path=/**</span></span><br></pre></td></tr></table></figure><p>或者如果我们是用 Java 代码方式配置的路由可以改成如下代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> RouteLocator <span class="title">routesConfig</span><span class="params">(RouteLocatorBuilder builder)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> builder.routes()</span><br><span class="line">.route(<span class="string">"route-demo"</span>,r -&gt; r.path(<span class="string">"/**"</span>).uri(<span class="string">"lb://dubbo-consumer"</span>))</span><br><span class="line">.build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改完成后，启动网关，然后访问网关地址 <a href="http://localhost:8080/consumer" rel="noopener" target="_blank"><code>http://localhost:8080/consumer</code></a> 就可以看到页面显示 <code>hello! This is Dubbo&#39;s demo</code></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;🤔为什么要双注册中心？&quot;&gt;&lt;a href=&quot;#🤔为什么要双注册中心？&quot; class=&quot;headerlink&quot; title=&quot;🤔为什么要双注册中心？&quot;&gt;&lt;/a&gt;🤔为什么要双注册中心？&lt;/h2&gt;&lt;p&gt;当前 Dubbo 版本注册粒度是以接口粒度来注册的，而 Sp
      
    
    </summary>
    
    
      <category term="Dubbo" scheme="http://blog.mjava.top/categories/Dubbo/"/>
    
    
      <category term="Dubbbo" scheme="http://blog.mjava.top/tags/Dubbbo/"/>
    
      <category term="Spring" scheme="http://blog.mjava.top/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>快速搭建一个SpringGateway网关</title>
    <link href="http://blog.mjava.top/spring/9944CC0FEBD34A3EBD04EAA1564F4C3A/"/>
    <id>http://blog.mjava.top/spring/9944CC0FEBD34A3EBD04EAA1564F4C3A/</id>
    <published>2021-05-07T13:05:58.000Z</published>
    <updated>2021-07-22T03:30:13.223Z</updated>
    
    <content type="html"><![CDATA[<h2 id="☝️搭建脚手架"><a href="#☝️搭建脚手架" class="headerlink" title="☝️搭建脚手架"></a>☝️搭建脚手架</h2><p>我们可以去 <a href="https://start.spring.io" rel="noopener" target="_blank">Spring initializer</a> 网站或者用 IDEA 来快速创建出一个 Spring Cloud Gateway 项目。</p><p>这里我们选择的注册中心是 Zookeeper，你也可以自己选择其他的注册中心来注册你的项目，比如阿里巴巴的 Nacos 等。</p><p><img src="http://cdn.mjava.top/blog/Untitled.png" alt="%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E7%BD%91%E5%85%B3%E9%A1%B9%E7%9B%AE%20f074aa733bd04ab885cacd0c71d9f94c/Untitled.png"></p><p>配置完相关信息后，点击下面的 <code>GENERATE</code> 按钮就可以导出项目的 <code>zip</code> 压缩包，解压后用 IDE 打开。</p><p>打开后就是这个样子：</p><p><img src="http://cdn.mjava.top/blog/Untitled%201.png" alt="%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E7%BD%91%E5%85%B3%E9%A1%B9%E7%9B%AE%20f074aa733bd04ab885cacd0c71d9f94c/Untitled%201.png"></p><h2 id="✌️配置路由"><a href="#✌️配置路由" class="headerlink" title="✌️配置路由"></a>✌️配置路由</h2><h3 id="Ymal-方式配置"><a href="#Ymal-方式配置" class="headerlink" title="Ymal 方式配置"></a>Ymal 方式配置</h3><p>为了方便配置，我们把 <code>application.properties</code> 改成 <code>application.yml</code> 。</p><p>然后配置一个转发到百度到路由。</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">  cloud:</span></span><br><span class="line"><span class="attr">    gateway:</span></span><br><span class="line"><span class="attr">      routes:</span></span><br><span class="line"><span class="attr">        - id:</span> <span class="string">route-demo</span></span><br><span class="line"><span class="attr">          uri:</span> <span class="attr">https://baidu.com</span></span><br><span class="line"><span class="attr">          predicates:</span></span><br><span class="line"><span class="bullet">            -</span> <span class="string">Path=/**</span></span><br></pre></td></tr></table></figure><p>在配置中，我加来一个谓词 <code>Path</code> ，表示所有当请求都会匹配到这个路由下，然后转发到 <code>uri</code> 配置到网址里。所以当我们打开浏览器访问 <code>[http://localhost:8080/](http://localhost:8080/)</code> 是就会自动跳转到百度到首页。</p><h3 id="Java-代码方式配置"><a href="#Java-代码方式配置" class="headerlink" title="Java 代码方式配置"></a>Java 代码方式配置</h3><p>除了用配置文件配置路由外，我们还可以用代码的方式来配置路由。</p><p>下面来展示一下代码方式配置的路由：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> RouteLocator <span class="title">routesConfig</span><span class="params">(RouteLocatorBuilder builder)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> builder.routes()</span><br><span class="line">.route(<span class="string">"route-demo"</span>,r -&gt; r.path(<span class="string">"/**"</span>).uri(<span class="string">"https://baidu.com"</span>))</span><br><span class="line">.build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这几行代码实现的是和上面配置一样的功能，当访问 <code>[http://localhost:8080/](http://localhost:8080/)</code> 时也会跳转到百度首页。</p><h2 id="👌注册到-Zookeeper"><a href="#👌注册到-Zookeeper" class="headerlink" title="👌注册到 Zookeeper"></a>👌注册到 Zookeeper</h2><p>接下来演示一下如何把网关注册到 Zookeeper。</p><p>首先在我们本地搭建好 Zookeeper，我这边是直接用 Docker 启动了一个 Zookeeper。</p><p>然后在配置文件添加如下配置：</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">  application:</span></span><br><span class="line"><span class="attr">    name:</span> <span class="string">weidain-gateway</span></span><br><span class="line"><span class="attr">  cloud:</span></span><br><span class="line"><span class="attr">    zookeeper:</span></span><br><span class="line"><span class="attr">      connect-string:</span> <span class="attr">localhost:2181</span></span><br></pre></td></tr></table></figure><p>上面到 <code>weidain-gateway</code> 是我们注册到 Zookeeper 上到服务名，地址 <code>[localhost:2181](http://localhost:2181)</code> 是我们本地 Zookeeper 注册中心到地址。</p><p>启动项目后，我们用 Zookeeper 可视化工具就可以看到注册中心多了一个 <code>services</code>  节点，节点下面有我们注册上去的 <code>weidain-gateway</code> 服务</p><p><img src="http://cdn.mjava.top/blog/Untitled%202.png" alt="%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E7%BD%91%E5%85%B3%E9%A1%B9%E7%9B%AE%20f074aa733bd04ab885cacd0c71d9f94c/Untitled%202.png"></p><p>下面就是我们网关服务注册到 Zookeeper 到数据：</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"name"</span>: <span class="string">"weidain-gateway"</span>,</span><br><span class="line">    <span class="attr">"id"</span>: <span class="string">"8c802a81-12e7-4f72-9034-aee00c0745bb"</span>,</span><br><span class="line">    <span class="attr">"address"</span>: <span class="string">"169.254.238.114"</span>,</span><br><span class="line">    <span class="attr">"port"</span>: <span class="number">8080</span>,</span><br><span class="line">    <span class="attr">"sslPort"</span>: <span class="literal">null</span>,</span><br><span class="line">    <span class="attr">"payload"</span>: &#123;</span><br><span class="line">        <span class="attr">"@class"</span>: <span class="string">"org.springframework.cloud.zookeeper.discovery.ZookeeperInstance"</span>,</span><br><span class="line">        <span class="attr">"id"</span>: <span class="string">"application-1"</span>,</span><br><span class="line">        <span class="attr">"name"</span>: <span class="string">"weidain-gateway"</span>,</span><br><span class="line">        <span class="attr">"metadata"</span>: &#123;</span><br><span class="line">            <span class="attr">"instance_status"</span>: <span class="string">"UP"</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">"registrationTimeUTC"</span>: <span class="number">1620118042689</span>,</span><br><span class="line">    <span class="attr">"serviceType"</span>: <span class="string">"DYNAMIC"</span>,</span><br><span class="line">    <span class="attr">"uriSpec"</span>: &#123;</span><br><span class="line">        <span class="attr">"parts"</span>: [</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="attr">"value"</span>: <span class="string">"scheme"</span>,</span><br><span class="line">                <span class="attr">"variable"</span>: <span class="literal">true</span></span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="attr">"value"</span>: <span class="string">"://"</span>,</span><br><span class="line">                <span class="attr">"variable"</span>: <span class="literal">false</span></span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="attr">"value"</span>: <span class="string">"address"</span>,</span><br><span class="line">                <span class="attr">"variable"</span>: <span class="literal">true</span></span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="attr">"value"</span>: <span class="string">":"</span>,</span><br><span class="line">                <span class="attr">"variable"</span>: <span class="literal">false</span></span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="attr">"value"</span>: <span class="string">"port"</span>,</span><br><span class="line">                <span class="attr">"variable"</span>: <span class="literal">true</span></span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;☝️搭建脚手架&quot;&gt;&lt;a href=&quot;#☝️搭建脚手架&quot; class=&quot;headerlink&quot; title=&quot;☝️搭建脚手架&quot;&gt;&lt;/a&gt;☝️搭建脚手架&lt;/h2&gt;&lt;p&gt;我们可以去 &lt;a href=&quot;https://start.spring.io&quot; rel=&quot;noope
      
    
    </summary>
    
    
      <category term="Spring" scheme="http://blog.mjava.top/categories/Spring/"/>
    
    
      <category term="SpringCloud" scheme="http://blog.mjava.top/tags/SpringCloud/"/>
    
      <category term="Gateway" scheme="http://blog.mjava.top/tags/Gateway/"/>
    
  </entry>
  
  <entry>
    <title>telnet使用smtp协议发送qq邮件</title>
    <link href="http://blog.mjava.top/protocol/4dd3868b-e23e-4446-b7ec-fd95e98612f4/"/>
    <id>http://blog.mjava.top/protocol/4dd3868b-e23e-4446-b7ec-fd95e98612f4/</id>
    <published>2021-03-23T10:36:44.000Z</published>
    <updated>2021-07-22T03:30:13.223Z</updated>
    
    <content type="html"><![CDATA[<h2 id="操作步骤"><a href="#操作步骤" class="headerlink" title="操作步骤"></a>操作步骤</h2><ol><li><p><code>telnet</code>命令调试QQ邮箱的<code>smtp</code>服务器</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">telnet smtp.qq.com 25</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 响应</span></span><br><span class="line">Trying 183.3.225.42...</span><br><span class="line">Connected to smtp.qq.com.</span><br><span class="line">Escape character is '^]'.</span><br><span class="line">220 newxmesmtplogicsvrsza5.qq.com XMail Esmtp QQ Mail Server.</span><br></pre></td></tr></table></figure></li><li><p>使用<code>EHLO</code>命令，指示<code>ESMTP</code>会话开始。服务器可以在它对 <code>EHLO</code> 的响应中表明自己支持 <code>ESMTP</code> 命令</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">EHLO smtp.qq.com</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 响应</span></span><br><span class="line">250-newxmesmtplogicsvrsza5.qq.com</span><br><span class="line">250-PIPELINING</span><br><span class="line">250-SIZE 73400320</span><br><span class="line">250-STARTTLS</span><br><span class="line">250-AUTH LOGIN PLAIN</span><br><span class="line">250-AUTH=LOGIN</span><br><span class="line">250-MAILCOMPRESS</span><br><span class="line">250 8BITMIME</span><br></pre></td></tr></table></figure></li><li><p>使用<code>AUTH</code>关键字进行身份验证，这里使用<code>AUTH LOGIN</code>，然后输入<code>Base64</code>编码的用户名和QQ邮箱<strong>授权码</strong></p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">AUTH LOGIN</span><br><span class="line">// base64编码的`Username:`</span><br><span class="line"><span class="meta">$</span><span class="bash"> 334 VXNlcm5hbWU6  </span></span><br><span class="line"></span><br><span class="line">// base64编码的`Password:`</span><br><span class="line"><span class="meta">$</span><span class="bash"> 334 UGFzc3dvcmQ6</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 响应</span></span><br><span class="line">235 Authentication successful</span><br></pre></td></tr></table></figure></li><li><p>使用<code>MAIL</code>命令，通过标识邮件的发件人来标识邮件传输开始；以 <code>MAIL FROM</code> 的形式使用。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">MAIL FROM:&lt;211019847@qq.com&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 响应</span></span><br><span class="line">250 OK.</span><br></pre></td></tr></table></figure></li><li><p>使用<code>RCPT</code>命令标识邮件的收件人；以 <code>RCPT TO</code> 的形式使用。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">RCPT TO:&lt;573419235@qq.com&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 响应</span></span><br><span class="line">250 OK</span><br></pre></td></tr></table></figure></li><li><p>使用<code>DATA</code>命令发送数据，以<code>.</code>符号代表结束</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">DATA</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 响应</span></span><br><span class="line">354 End data with &lt;CR&gt;&lt;LF&gt;.&lt;CR&gt;&lt;LF&gt;.</span><br></pre></td></tr></table></figure></li><li><p>输入内容</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">FROM: 211019847@qq.com</span><br><span class="line">TO: 573419235@qq.com</span><br><span class="line">SUBJECT: shell email</span><br><span class="line"></span><br><span class="line">this is body msg!</span><br><span class="line">.</span><br></pre></td></tr></table></figure></li><li><p>使用<code>QUIT</code>命令退出</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">QUIT</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 响应</span></span><br><span class="line">221 Bye.</span><br><span class="line">Connection closed by foreign host.</span><br></pre></td></tr></table></figure></li></ol><p>此时，<code>573419235@qq.com</code>邮箱就会收到一封标题为<strong>shell email</strong>,内容为</p><p><em>this is body msg!</em>的邮件了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;操作步骤&quot;&gt;&lt;a href=&quot;#操作步骤&quot; class=&quot;headerlink&quot; title=&quot;操作步骤&quot;&gt;&lt;/a&gt;操作步骤&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;telnet&lt;/code&gt;命令调试QQ邮箱的&lt;code&gt;smtp&lt;/code&gt;服务器&lt;/p&gt;

      
    
    </summary>
    
    
      <category term="Protocol" scheme="http://blog.mjava.top/categories/Protocol/"/>
    
    
      <category term="smtp" scheme="http://blog.mjava.top/tags/smtp/"/>
    
      <category term="telnet" scheme="http://blog.mjava.top/tags/telnet/"/>
    
  </entry>
  
  <entry>
    <title>【go库】钉钉机器人</title>
    <link href="http://blog.mjava.top/golang/47ca1795-f020-44a6-9847-02ef3955f6c9/"/>
    <id>http://blog.mjava.top/golang/47ca1795-f020-44a6-9847-02ef3955f6c9/</id>
    <published>2021-03-19T14:18:58.000Z</published>
    <updated>2021-07-22T03:30:13.219Z</updated>
    
    <content type="html"><![CDATA[<p>钉钉机器人 go库</p><p>github地址：<a href="https://github.com/greycodee/dingbot" rel="noopener" target="_blank">https://github.com/greycodee/dingbot</a></p><p><a href="https://developers.dingtalk.com/document/app/custom-robot-access" rel="noopener" target="_blank">钉钉官方文档</a></p><h2 id="快速开始"><a href="#快速开始" class="headerlink" title="快速开始"></a>快速开始</h2><figure class="highlight shell"><figcaption><span>script</span></figcaption><table><tr><td class="code"><pre><span class="line">go get github.com/greycodee/dingbot</span><br></pre></td></tr></table></figure><p>示例程序：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"github.com/greycodee/dingbot"</span></span><br><span class="line"><span class="string">"github.com/greycodee/dingbot/message"</span></span><br><span class="line"><span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">bot:= dingbot.DingBot&#123;</span><br><span class="line">Secret:      <span class="string">"你的加签秘钥"</span>,</span><br><span class="line">AccessToken: <span class="string">"你的AccessToken【从钉钉机器人的url上获取】"</span>,</span><br><span class="line">&#125;</span><br><span class="line">msg := message.Message&#123;</span><br><span class="line">MsgType: message.TextStr,</span><br><span class="line">Text:    message.Text_&#123;</span><br><span class="line">Content: <span class="string">"go-钉钉机器人测试"</span>,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;</span><br><span class="line">bot.Send(msg)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="消息支持"><a href="#消息支持" class="headerlink" title="消息支持"></a>消息支持</h2><ul><li><input checked disabled type="checkbox"> text类型</li><li><input checked disabled type="checkbox"> link类型</li><li><input checked disabled type="checkbox"> markdown类型</li><li><input checked disabled type="checkbox"> 整体跳转ActionCard类型</li><li><input checked disabled type="checkbox"> 独立跳转ActionCard类型</li><li><input checked disabled type="checkbox"> FeedCard类型</li></ul><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><h3 id="发送Text消息"><a href="#发送Text消息" class="headerlink" title="发送Text消息"></a>发送Text消息</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">send</span><span class="params">()</span></span> &#123;</span><br><span class="line">bot:= dingbot.DingBot&#123;</span><br><span class="line">Secret:      <span class="string">"你的加签秘钥"</span>,</span><br><span class="line">AccessToken: <span class="string">"你的AccessToken【从钉钉机器人的url上获取】"</span>,</span><br><span class="line">&#125;</span><br><span class="line">msg := message.Message&#123;</span><br><span class="line">        MsgType: message.TextStr,</span><br><span class="line">        Text:    message.Text_&#123;</span><br><span class="line">            Content: <span class="string">"go-钉钉机器人测试"</span>,</span><br><span class="line">            At: message.At_&#123;</span><br><span class="line">                AtMobiles: []<span class="keyword">string</span>&#123;<span class="string">"188xxxxxxxx"</span>&#125;,</span><br><span class="line">                IsAtAll:   <span class="literal">false</span>,</span><br><span class="line">            &#125;,</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;</span><br><span class="line">bot.Send(msg)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="发送link类型消息"><a href="#发送link类型消息" class="headerlink" title="发送link类型消息"></a>发送link类型消息</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">send</span><span class="params">()</span></span> &#123;</span><br><span class="line">bot:= dingbot.DingBot&#123;</span><br><span class="line">Secret:      <span class="string">"你的加签秘钥"</span>,</span><br><span class="line">AccessToken: <span class="string">"你的AccessToken【从钉钉机器人的url上获取】"</span>,</span><br><span class="line">&#125;</span><br><span class="line">msg := message.Message&#123;</span><br><span class="line">        MsgType: message.LinkStr,</span><br><span class="line">        Link: message.Link_&#123;</span><br><span class="line">            Text:       <span class="string">"link测试123123"</span>,</span><br><span class="line">            Title:      <span class="string">"go钉钉机器人"</span>,</span><br><span class="line">            PicUrl:     <span class="string">""</span>,</span><br><span class="line">            MessageUrl: <span class="string">"https://developers.dingtalk.com/document/app/custom-robot-access/title-72m-8ag-pqw"</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">bot.Send(msg)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="发送markdown类型消息"><a href="#发送markdown类型消息" class="headerlink" title="发送markdown类型消息"></a>发送markdown类型消息</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">send</span><span class="params">()</span></span> &#123;</span><br><span class="line">bot:= dingbot.DingBot&#123;</span><br><span class="line">Secret:      <span class="string">"你的加签秘钥"</span>,</span><br><span class="line">AccessToken: <span class="string">"你的AccessToken【从钉钉机器人的url上获取】"</span>,</span><br><span class="line">&#125;</span><br><span class="line">msg := message.Message&#123;</span><br><span class="line">        MsgType: message.MarkdownStr,</span><br><span class="line">        Markdown: message.Markdown_&#123;</span><br><span class="line">            Title: <span class="string">"go钉钉"</span>,</span><br><span class="line">            Text:  <span class="string">"## go钉钉测试 @188xxxxxxxx \n&gt;文本123"</span>,</span><br><span class="line">            At:    message.At_&#123;</span><br><span class="line">                AtMobiles: []<span class="keyword">string</span>&#123;<span class="string">"188xxxxxxxx"</span>&#125;,</span><br><span class="line">                IsAtAll:   <span class="literal">false</span>,</span><br><span class="line">            &#125;,</span><br><span class="line">        &#125;,</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">bot.Send(msg)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="发送整体跳转ActionCard类型消息"><a href="#发送整体跳转ActionCard类型消息" class="headerlink" title="发送整体跳转ActionCard类型消息"></a>发送整体跳转ActionCard类型消息</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">send</span><span class="params">()</span></span> &#123;</span><br><span class="line">bot:= dingbot.DingBot&#123;</span><br><span class="line">Secret:      <span class="string">"你的加签秘钥"</span>,</span><br><span class="line">AccessToken: <span class="string">"你的AccessToken【从钉钉机器人的url上获取】"</span>,</span><br><span class="line">&#125;</span><br><span class="line">msg := message.Message&#123;</span><br><span class="line">        MsgType: message.ActionCardStr,</span><br><span class="line">        ActionCard: message.ActionCard_&#123;</span><br><span class="line">            Title:          <span class="string">"ActionCard整体跳转11"</span>,</span><br><span class="line">            Text:           <span class="string">"ActionCardt整体跳转1223"</span>,</span><br><span class="line">            SingleTitle:    <span class="string">"阅读全文"</span>,</span><br><span class="line">            SingleURL:      <span class="string">"https://developers.dingtalk.com/document/app/custom-robot-access/title-72m-8ag-pqw"</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;</span><br><span class="line">bot.Send(msg)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="发送独立跳转ActionCard类型消息"><a href="#发送独立跳转ActionCard类型消息" class="headerlink" title="发送独立跳转ActionCard类型消息"></a>发送独立跳转ActionCard类型消息</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">send</span><span class="params">()</span></span> &#123;</span><br><span class="line">    bot:= dingbot.DingBot&#123;</span><br><span class="line">        Secret:      <span class="string">"你的加签秘钥"</span>,</span><br><span class="line">        AccessToken: <span class="string">"你的AccessToken【从钉钉机器人的url上获取】"</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    msg := message.Message&#123;</span><br><span class="line">        MsgType: message.ActionCardStr,</span><br><span class="line">        ActionCard: message.ActionCard_&#123;</span><br><span class="line">            Title:          <span class="string">"ActionCard跳转11"</span>,</span><br><span class="line">            Text:           <span class="string">"ActionCardt跳转1223"</span>,</span><br><span class="line">            BtnOrientation: <span class="string">"1"</span>,</span><br><span class="line">            HideAvatar:     <span class="string">"0"</span>,</span><br><span class="line">            BtnS:           []message.Btn_&#123;</span><br><span class="line">                &#123;</span><br><span class="line">                    Title:     <span class="string">"按钮1"</span>,</span><br><span class="line">                    ActionURL: <span class="string">"https://developers.dingtalk.com/"</span>,</span><br><span class="line">                &#125;,</span><br><span class="line">                &#123;</span><br><span class="line">                    Title:     <span class="string">"按钮2"</span>,</span><br><span class="line">                    ActionURL: <span class="string">"https://developers.dingtalk.com/"</span>,</span><br><span class="line">                &#125;,</span><br><span class="line">            &#125;,</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;</span><br><span class="line">    bot.Send(msg)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="发送FeedCard类型消息"><a href="#发送FeedCard类型消息" class="headerlink" title="发送FeedCard类型消息"></a>发送FeedCard类型消息</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">send</span><span class="params">()</span></span> &#123;</span><br><span class="line">    bot:= dingbot.DingBot&#123;</span><br><span class="line">        Secret:      <span class="string">"你的加签秘钥"</span>,</span><br><span class="line">        AccessToken: <span class="string">"你的AccessToken【从钉钉机器人的url上获取】"</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    msg := message.Message&#123;</span><br><span class="line">        MsgType:  message.FeedCardStr,</span><br><span class="line">        FeedCard: message.FeedCard_&#123;[]message.Link_&#123;</span><br><span class="line">            &#123;</span><br><span class="line">                Title:      <span class="string">"标题1"</span>,</span><br><span class="line">                PicUrl:     <span class="string">""</span>,</span><br><span class="line">                MessageUrl: <span class="string">"https://developers.dingtalk.com/"</span>,</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                Title:      <span class="string">"标题2"</span>,</span><br><span class="line">                PicUrl:     <span class="string">""</span>,</span><br><span class="line">                MessageUrl: <span class="string">"https://developers.dingtalk.com/"</span>,</span><br><span class="line">            &#125;,</span><br><span class="line">        &#125;&#125;,</span><br><span class="line">    &#125;</span><br><span class="line">    bot.Send(msg)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;钉钉机器人 go库&lt;/p&gt;
&lt;p&gt;github地址：&lt;a href=&quot;https://github.com/greycodee/dingbot&quot; rel=&quot;noopener&quot; target=&quot;_blank&quot;&gt;https://github.com/greycodee/ding
      
    
    </summary>
    
    
      <category term="Go" scheme="http://blog.mjava.top/categories/Go/"/>
    
    
      <category term="Go" scheme="http://blog.mjava.top/tags/Go/"/>
    
      <category term="钉钉机器人" scheme="http://blog.mjava.top/tags/%E9%92%89%E9%92%89%E6%9C%BA%E5%99%A8%E4%BA%BA/"/>
    
  </entry>
  
  <entry>
    <title>go自定义库上传github下载不了问题</title>
    <link href="http://blog.mjava.top/golang/e1273901-26b1-4cfb-a55c-a9f5047855a5/"/>
    <id>http://blog.mjava.top/golang/e1273901-26b1-4cfb-a55c-a9f5047855a5/</id>
    <published>2021-03-19T11:39:50.000Z</published>
    <updated>2021-07-22T03:30:13.219Z</updated>
    
    <content type="html"><![CDATA[<h2 id="自定义库上传github标签规范"><a href="#自定义库上传github标签规范" class="headerlink" title="自定义库上传github标签规范"></a>自定义库上传github标签规范</h2><p>当自己写的库要上传到<strong>github</strong>时,标签号要符合<code>vX.Y.Z</code>的格式，例如<code>v1.0.0</code></p><p>如果定义其他的标签格式，则<code>go</code>会下载不到，例如<code>v1.0</code>,此时如果用<code>go get</code>命令下载的话，则下载不到此版本</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;自定义库上传github标签规范&quot;&gt;&lt;a href=&quot;#自定义库上传github标签规范&quot; class=&quot;headerlink&quot; title=&quot;自定义库上传github标签规范&quot;&gt;&lt;/a&gt;自定义库上传github标签规范&lt;/h2&gt;&lt;p&gt;当自己写的库要上传到&lt;str
      
    
    </summary>
    
    
      <category term="Go" scheme="http://blog.mjava.top/categories/Go/"/>
    
    
      <category term="Go" scheme="http://blog.mjava.top/tags/Go/"/>
    
  </entry>
  
</feed>
